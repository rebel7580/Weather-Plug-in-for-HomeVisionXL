#! Weather plug-in - Ron Boston
#
# Version: 5.3b
# $Revision: 1.59 $
# $Date: 2021/12/10 17:19:23 $
# $Requires: HomeVisionXL 2.1 $

set version {$Id: weather.hap,v 1.59 2021/12/10 17:19:23 ron Exp $}

hvImport ControlSetVar
hvImport debug

# This plugin uses features introduced in version 2.1
if {[hvVersion] < 2.0 || ![package vsatisfies [hvVersion] 2.1-]} {
    error "Need HomeVisionXL version 2.1 or higher"
}

if {[hvGuiInit]} {
    # Add weather configuration to the menu
    if {[catch {hvMenu Main cget Plugins -menu} menu]} {
        set menu Main.plugins
        hvMenu Main add cascade -label Plugins -menu $menu -underline 0
    }
    hvMenu $menu add command -label "Weather" -command [list configure]

    # If help file exists, add it to the menu
    if {[hvHelpFile weather.hlp]} {
        if {[catch {hvMenu Help cget Plugins -menu} menu]} {
            set menu Help.plugins
            hvMenu Help add cascade -label Plugins -menu $menu
        }
        hvMenu $menu add command -label "Weather" -command [list hvHelp index]
    }
}

#! Plugin directory location
set script [file normalize [file join [pwd] [info script]]]
set dir [file dirname $script]
lappend auto_path $dir
#fix for TLS libssl.so.1.0.0 missing in Debian 10
if {$tcl_platform(machine) eq "x86_64"} {
    lappend auto_path /usr/lib/tcltk/x86_64-linux-gnu
}
tcl::tm::path add $dir

set Icondir [file join $dir weather images]
set Iconext ".png"

#! HV Configuration variables
array set Config {
    StationID           "KNYC"
    StationIDFc         "KNYC"
    StateCurrent        "NY"
    StationNameCurrent  "New York City, Central Park"
    ReadTime            15
    ReadEnable          1
    TempScale           "H"
    SpeedScale          "M"
    PressureScale       "I"
    HVWeatherEnable     0
    HVWeatherVar        256
    HVObsTimeVar        256
    HVObsDateVar        256
    HVStationIDVar      256
    HVPoPVar            256
    HVCloudVar          256
    TimeFormat          "H"
    WeatherType         "X"
    DataSource          "Web"
    FileSource          ""
    FileSourceFc        ""
    SpeechEnable        0
    SpeechConfig        {00 00 00 00 00 00 00 00 00 00 00}
    StickyConfig        0
    ForecastEnable      N
    LocSelection        0
    ZipCode             ""
    ZipCodeFc           ""
    Latitude            "0"
    Longitude           "0"
    LatitudeFc          "0"
    LongitudeFc         "0"
    ConsumerKey         ""
    SearchType          S
    SearchTypeFc        H
    LineLength          70
    PopPeriod           1
    WxVarConfig         {00 00 00 00 00 00 00 00 00}
    FxVarConfig         {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    WxWebConfig         {00 00 00 00 00 00 00 00 00}
    FxWebConfig         {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    WxMqttConfig        {00 00 00 00 00 00 00 00 00}
    FxMqttConfig        {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    Icontype            "S"
    IconsizeC           ""
    IconsizeF           ""
    Geometry            ""
    ShortStationList    1
    ShowStations        1
    MapLink             "https://www.google.com/maps/search/?api=1&query=<lat>,<lon>"
    Language            "English"
    CurrentTab          1
    StateTopic          ""
    CmndTopic           ""
    MqttRetain          0
}

array set linkConfig {
    WebLink             "https://w1.weather.gov/xml/current_obs"
    WebLinkFc           "https://graphical.weather.gov/xml/SOAP_server"
    WebLinkWb           "https://api.openweathermap.org"
    WebLinkWbIcons      "https://openweathermap.org/img/wn"
    FTPServer           "tgftp.nws.noaa.gov"
    FTPDir              "data/observations/metar/stations"
    FTPMode             "passive"
}

foreach link [array names linkConfig] {
    set Config($link) $linkConfig($link)
}

array set HVVarSize {
    HVWeatherVar        1
    HVObsTimeVar        2
    HVObsDateVar        2
    HVStationIDVar      5
    HVPoPVar            1
    HVCloudVar          1
}

set Spcfg {
Location {bit 255 byte 1}
Station {bit 255 byte 2}
Weather {bit 255 byte 3}
Temperature {bit 255 byte 4}
Dewpoint {bit 255 byte 5}
Windchill {bit 255 byte 6}
Heatindex {bit 255 byte 7}
Wind {bit 255 byte 8}
Humidity {bit 255 byte 9}
Pressure {bit 255 byte 10}
Visibility {bit 255 byte 11}
Clouds {bit 255 byte 12}
}

#! These are all of the values (currently) available on the NWS XML pages,
#  with the exception of the following, which are expansions and/or METAR items:
#    WindKPH WindKTS WindBft WindGustKPH WindGustKTS PressureMm VisibilityKm
#
#  First value is the tag from NWS XML file,
#  second is the Control Variable name that will be set to the tag's value.
#
array set Cvar {
    location            Location
    latitude            Lat
    longitude           Long
    station_id          Station
    observation_time    ObservationTime
    observation_time_rfc822 ObservationTimerfc822
    weather             Weather
    temperature_string  Temp
    temp_f              TempF
    temp_c              TempC
    relative_humidity   Humidity
    wind_string         Wind
    wind_dir            WindDir
    wind_degrees        WindDegrees
    wind_mph            WindMPH
    wind_kph            WindKPH
    wind_kt             WindKTS
    wind_bea            WindBft
    wind_gust_mph       WindGustMPH
    wind_gust_kph       WindGustKPH
    wind_gust_kt        WindGustKTS
    pressure_string     Pressure
    pressure_mb         PressureMb
    pressure_in         PressureIn
    pressure_mm         PressureMm
    dewpoint_string     Dewpoint
    dewpoint_f          DewpointF
    dewpoint_c          DewpointC
    heat_index_string   HeatIndex
    heat_index_f        HeatIndexF
    heat_index_c        HeatIndexC
    windchill_string    Windchill
    windchill_f         WindchillF
    windchill_c         WindchillC
    visibility_mi       VisibilityMi
    visibility_km       VisibilityKm
    icon_url_name       WeatherIcon
    icon_url_base       IconBase
}

#! Icon names associated with weather condition code for HV weather variable.
array set IconNames {
    na          0
    skc         1       nskc    1
    few         2       nfew    2
    sct         3       nsct    3
    bkn         4       nbkn    4
    ovc         5       novc    5
    fg          6       nfg     6
    wind        7       nwind   7
    shra        8
    hi_nshwrs   9       hi_shwrs 9
    ra1         10
    nra         11      ra      11
    raip        12      nraip   12
    fzrara      13
    frza        14
    mix         15      nmix    15
    rasn        16      nrasn   16
    sn          17      nsn     17
    ip          18
    hi_ntsra    19      hi_tsra 19
    scttsra     20      nscttsra 20
    tsra        21      ntsra   21
    nsvrtsra    22
    mist        23
    fu          24      smoke   24
    dust        25
    blizzard    26
    cold        27
    hot         28

    800         1       801     2
    802         3       803     4
    804         5

    200         21      201     21
    202         21      210     21
    211         21      221     21
    230         21      231     21
    232         21

    300         10      301     10
    302         10      310     10
    310         10      311     10
    312         10      313     10
    314         10      321     10

    500         10      501     11
    502         11      503     11
    504         11      511     14
    520         10      521     11
    522         11      531     9

    600        17       601     17
    602        17       611     14
    612        14       613     14
    615        16       616     16
    620        17       621     17
    622        17

    701         23      711     24
    721         23      731     25
    741         6       751     25
    761         25      762     30
    771         31      781     22
}

set LanguageVals {
    Afrikaans               af
    Albanian                al
    Arabic                  ar
    Azerbaijani             az
    Bulgarian               bg
    Catalan                 ca
    Czech                   cz
    Danish                  da
    German                  de
    Greek                   el
    English                 en
    Spanish                 es
    Basque                  eu
    "Persian (Farsi)"       fa
    Finnish                 fi
    French                  fr
    Galician                gl
    Hebrew                  he
    Hindi                   hi
    Croatian                hr
    Hungarian               hu
    Indonesian              id
    Italian                 it
    Japanese                ja
    Korean                  kr
    Latvian                 la
    Lithuanian              lt
    Macedonian              mk
    Dutch                   nl
    Norwegian               no
    Polish                  pl
    Portuguese              pt
    "Português Brasil"      pt_br
    Romanian                ro
    Russian                 ru
    Swedish                 sv
    Slovak                  sk
    Slovenian               sl
    Serbian                 sr
    Thai                    th
    Turkish                 tr
    Ukrainian               uk
    Vietnamese              vi
    "Chinese Simplified"    zh_cn
    "Chinese Traditional"   zh_tw
    Zulu    zu
}

#set sercmdtrig 0
set WxFcEnable "C"
set CtlWebEnable "C"
set WxAfter ""

#! one-time startup initialization of plugin
proc start {} {
    global Config Spcfg version

    # If Wizard Proxy is set up, use it for http
    if {![catch {hvVariable WizardProxy} proxy]} {
        set re {(?:http://)?(?:(?:([^:@/]+):)?([^:@/]+)@)?([^:@/]+)(?::([^:@/]*))?/?}
        if {[regexp $re $proxy -> user pass ProxyHost ProxyPort]} {
            debug "proxyhost: $ProxyHost; proxyport: $ProxyPort"
            ::http::config -proxyhost $ProxyHost -proxyport $ProxyPort
        }
    }

    # Remove WB API type
    if {![catch {hvConfig WbAPIType} tmp]} {
        hvConfig WbAPIType ""
    }

    # Check config file for values or use defaults if doesn't exist
    foreach n [array names Config] {
        if {[string match {Icon*} $n]} continue
        if {![catch {hvConfig $n} tmp]} {
            set Config($n) $tmp
        }
    }
# ################## Remove this section:
    # 5.3 and later, remove Weatherbug choice from current and forecast data source selection.
    if {$Config(WeatherType) eq "W"} {
#        set Config(WeatherType)  "X" 
    }
    if {$Config(ForecastEnable) eq "W"} {
#        set Config(ForecastEnable)  "X" 
    }
# ################## Remove above section

    # 3.x and earlier to 4.0: If using old time format, update to new
    # This should only run once, after upgrade.
    if {$Config(TimeFormat) ni {U E H}} {
        set Config(TimeFormat) "H"
    }

    # 3.x and earlier to 4.0: If using old speech config, update to new, and remove old config items
    # This should only run once, after upgrade.
    if {[catch {hvConfig SpeechConfig}]} {
        foreach n {Location Station Weather Temperature Dewpoint \
            Windchill Heatindex Wind Humidity Pressure Visibility}\
                s {SpeechLoc SpeechSid SpeechWeat SpeechTemp SpeechDewp \
            SpeechWindc SpeechHeat SpeechWind SpeechHumi SpeechPres SpeechVisi } {
            set ixn [dict get $Spcfg $n byte]
            incr ixn -1
            if {[catch {hvConfig $s} tmp]} {
                set tmp 0
            }
            set Config(SpeechConfig) [lreplace $Config(SpeechConfig) $ixn $ixn [format "%02x" $tmp]]
            hvConfig $s ""
        }
        hvConfig SpeechConfig $Config(SpeechConfig)
    }

    # 3.x and earlier to 4.0: If using old HV var config, update to new, and remove old config items
    # This should only run once, after upgrade.
    if {[catch {hvConfig HVObsTimeVar}]} {
        set wvar $Config(HVWeatherVar)
        if {$wvar != 256} {
            incr wvar
            if {![catch {hvConfig HVObsTime} ot]} {
                if {$ot == 1} {
                    set Config(HVObsTimeVar) $wvar
                    incr wvar 2
                }
                hvConfig HVObsTimeVar $Config(HVObsTimeVar)
                hvConfig HVObsTime ""
            }
            if {![catch {hvConfig HVObsDate} ot]} {
                if {$ot == 1} {
                    set Config(HVObsDateVar) $wvar
                }
                hvConfig HVObsDateVar $Config(HVObsDateVar)
                hvConfig HVObsDate ""
            }
        }
    }
    
    # 5.1 and earlier to 5.2 or later: add bytes to Wx configs
    # This should only run once, after upgrade.
    while {[llength $Config(WxVarConfig)] < 9} {
        lappend Config(WxVarConfig) "00"
    }
    while {[llength $Config(WxWebConfig)] < 9} {
        lappend Config(WxWebConfig) "00"
    }
    while {[llength $Config(WxMqttConfig)] < 9} {
        lappend Config(WxMqttConfig) "00"
    }
    # 5.2 and earlier to 5.3 or later: add bytes to Fx configs
    # This should only run once, after upgrade.
    while {[llength $Config(FxVarConfig)] < 45} {
        lappend Config(FxVarConfig) "00"
    }
    while {[llength $Config(FxWebConfig)] < 45} {
        lappend Config(FxWebConfig) "00"
    }
    while {[llength $Config(FxMqttConfig)] < 45} {
        lappend Config(FxMqttConfig) "00"
   }
    # Clear any enable flags for newly excluded items
    #  (CityCode, PressureRate, PressureRateIn, PressureRateMb
    lset Config(WxMqttConfig) 7 [format %.2X [expr {[scan [lindex $Config(WxMqttConfig) 7] %2x] & ~0x10}]]
    lset Config(WxVarConfig) 7 [format %.2X [expr {[scan [lindex $Config(WxVarConfig) 7] %2x] & ~0x10}]]
    lset Config(WxWebConfig) 7 [format %.2X [expr {[scan [lindex $Config(WxWebConfig) 7] %2x] & ~0x10}]]
    lset Config(WxMqttConfig) 8 [format %.2X [expr {[scan [lindex $Config(WxMqttConfig) 8] %2x] & ~0x07}]]
    lset Config(WxVarConfig) 8 [format %.2X [expr {[scan [lindex $Config(WxVarConfig) 8] %2x] & ~0x07}]]
    lset Config(WxWebConfig) 8 [format %.2X [expr {[scan [lindex $Config(WxWebConfig) 8] %2x] & ~0x07}]]
    # 5.2 and earlier to 5.3 or later: add bytes to Fx configs
    # This should only run once, after upgrade.

    while {[llength $Config(SpeechConfig)] < [dict size $Spcfg]} {
        lset Config(SpeechConfig) end+1 "00"
   }

    # 5.2 to 5.3: Add new, Delete unused
    foreach item {HVCloudVar WxMqttConfig FxMqttConfig Language CurrentTab StateTopic CmndTopic MqttRetain} {
        if {[catch {hvConfig $item}]} {
            hvConfig $item $Config($item)
    }
    }
    foreach item {IconstyleC IconstyleF Icontype WbExpiry ConsumerSecretKey AccessCode AccessToken CityCode CityCodeFc} {
        if {![catch {hvConfig $item} tmp]} {
            hvConfig $item ""
        }
    }
    
    debug "$version" red
    init
}

#!  Init called when plugin is started or after changing configuration info
proc init {} {
    global Config LinkA StationNames LanguageVals
    global Wxcfg Fxcfg Spcfg Wx Fx
debug "init" green
    stationrefresh

    initwxdata "" ""
    dict for {name info} $Wxcfg {
        dict with info {
            set byte [expr {abs([dict get $Wxcfg $name byte])-1}]
            set flags [scan [lindex $Config(WxVarConfig) $byte] {%x}]
            if {$flags & [dict get $Wxcfg $name bit]} {
                dict set Wxcfg $name ctl_enable 1
            } else {
                dict set Wxcfg $name ctl_enable 0
            }
            set byte [expr {abs([dict get $Wxcfg $name byte])-1}]
            set flags [scan [lindex $Config(WxWebConfig) $byte] {%x}]
            if {$flags & [dict get $Wxcfg $name bit]} {
                dict set Wxcfg $name web_enable 1
            } else {
                dict set Wxcfg $name web_enable 0
            }
            set flags [scan [lindex $Config(WxMqttConfig) $byte] {%x}]
            if {$flags & [dict get $Wxcfg $name bit]} {
                dict set Wxcfg $name mqtt_enable 1
            } else {
                dict set Wxcfg $name mqtt_enable 0
            }
        }
    }

    initfxdata ""
    dict for {name info} $Fxcfg {
        dict with info {
            set byte [expr {abs([dict get $Fxcfg $name byte])-1}]
            set flags [scan [lindex $Config(FxVarConfig) $byte] {%x}]
            if {$flags & [dict get $Fxcfg $name bit]} {
                dict set Fxcfg $name ctl_enable 1
            } else {
                dict set Fxcfg $name ctl_enable 0
            }
            set byte [expr {abs([dict get $Fxcfg $name byte])-1}]
            set flags [scan [lindex $Config(FxWebConfig) $byte] {%x}]
            if {$flags & [dict get $Fxcfg $name bit]} {
                dict set Fxcfg $name web_enable 1
            } else {
                dict set Fxcfg $name web_enable 0
            }
            set flags [scan [lindex $Config(FxMqttConfig) $byte] {%x}]
            if {$flags & [dict get $Fxcfg $name bit]} {
                dict set Fxcfg $name mqtt_enable 1
            } else {
                dict set Fxcfg $name mqtt_enable 0
            }
        }
    }

    dict for {name info} $Spcfg {
        dict with info {
            set byte [expr {abs($byte)-1}]
            set flags [scan [lindex $Config(SpeechConfig) $byte] {%x}]
            if {$flags & $bit} {
                dict set Spcfg $name enable $flags
            } else {
                dict set Spcfg $name enable 0
            }
        }
    }

    if {[tempscale] eq "C"} {
        set units "0"
    } else {
        set units "1"
    }

#   set station $Config(StationID)
    lassign [split $Config(StationID) ,] station provider
    set owxsearch {}
    if {$Config(SearchType) eq "S"} {
        if {[array names StationNames -exact "$station,lat"] ne ""} {
            set owxsearch "lat=$StationNames($station,lat)&lon=$StationNames($station,lon)"
        }
    } elseif {$Config(SearchType) eq "Z"} {
        set latlon [geozip $Config(ZipCode)]
#        debug "latlon:$latlon" red
        set station [findstation [lindex $latlon 0] [lindex $latlon 1]]
        set owxsearch "lat=[lindex $latlon 0]&lon=[lindex $latlon 1]"
        set Wx(Station) $station
    } elseif {$Config(SearchType) eq "L"} {
        set station [findstation $Config(Latitude) $Config(Longitude)]
        set owxsearch "lat=$Config(Latitude)&lon=$Config(Longitude)"
    } elseif {$Config(SearchType) eq "H"} {
        set station [findstation [hvVariable Latitude] [hvVariable Longitude]]
        set owxsearch "lat=[hvVariable Latitude]&lon=[hvVariable Longitude]"
    }
    set Wx(Station) $station
    debug "STA:$Wx(Station)" red

    lassign [split $Config(StationIDFc) ,] st provider
    set nwssearchFc ""
    set owxsearchFc ""
    if {$Config(SearchTypeFc) eq "S"} {
        if {[array names StationNames -exact "$st,lat"] ne ""} {
        	set nwssearchFc "lat=$StationNames($st,lat)&lon=$StationNames($st,lon)"
            set owxsearchFc $nwssearchFc
        }
    } elseif {$Config(SearchTypeFc) eq "Z"} {
        set nwssearchFc "zipCodeList=$Config(ZipCodeFc)"
        set latlon [geozip $Config(ZipCodeFc)]
        set owxsearchFc "lat=[lindex $latlon 0]&lon=[lindex $latlon 1]"
    } elseif {$Config(SearchTypeFc) eq "L"} {
        set nwssearchFc "lat=$Config(Latitude)&lon=$Config(Longitude)"
        set owxsearchFc $nwssearchFc
    } elseif {$Config(SearchTypeFc) eq "H"} {
        set nwssearchFc "lat=[hvVariable Latitude]&lon=[hvVariable Longitude]"
        set owxsearchFc $nwssearchFc
    }
    array unset LinkA
    set LinkA(wbcurproto) [format \
        {%s/data/2.5/onecall?appid=%%s&%s&units=%s&exclude=hourly,minutely,alerts&lang=%s} \
        $Config(WebLinkWb) $owxsearch [expr {$units == 0 ? "metric" : "imperial"}] [dict get $LanguageVals $Config(Language)]]
    set LinkA(wbfcproto) [format \
        {%s/data/2.5/onecall?appid=%%s&%s&units=%s&exclude=hourly,minutely,alerts&lang=%s} \
        $Config(WebLinkWb) $owxsearchFc [expr {$units == 0 ? "metric" : "imperial"}] [dict get $LanguageVals $Config(Language)]]
    set LinkA(wbiconsproto) [format \
        {%s} \
        $Config(WebLinkWbIcons)]
    set LinkA(wbicons) [format \
        {%s} \
        $Config(WebLinkWbIcons)]
    set LinkA(nwsfc) [format \
        {%s/ndfdSOAPclientByDay.php?%s&format=12+hourly&startDate=%%s&numDays=7&Submit=Submit} \
        $Config(WebLinkFc) $nwssearchFc]
    set LinkA(nwscur) [format \
        {%s/%s.xml} \
        $Config(WebLink) $station]

    set LinkA(station) [format \
        {%s/%s.xml} \
        $Config(WebLink) index]

    subscribe
    
    foreach n [lsort -dictionary [array names Config]] {
        debug "$n: $Config($n)"
    }
    foreach n [lsort -dictionary [array names LinkA]] {
        debug "Link $n: $LinkA($n)" red
    }
}

#!  Configuration dialog
proc configure {{type 0}} {

    global Config tmpConfig
    global LinkA tmpLinkA
    global StationNames HVVarSize
    global FetchMsg
    global SpeakActive SpeakInactive
    global CtlVarInactive CtlVarActive WxFcEnable
    global LanguageVals

    if {$type == 0} {
        foreach n [array names Config] {
            set tmpConfig($n) $Config($n)
        }
        foreach n [array names LinkA] {
            set tmpLinkA($n) $LinkA($n)
        }
    }

    set FetchMsg ""

    if {[winfo exists .cfg]} {
        wm withdraw  .cfg
        wm deiconify .cfg
        return
    }

    ttk::toplevel .cfg
    wm withdraw   .cfg
    wm title      .cfg "Configure Weather Data"
    wm resizable  .cfg 0 0
    ttk::notebook .cfg.n
    .cfg.n configure -cursor ""
    ttk::notebook::enableTraversal .cfg.n

    # Create new radiobutton style to remove extraneous focus highlight
    # for radio buttons that have no text
    ttk::style layout Wx.TRadiobutton {
        Radiobutton.padding -sticky nswe -children {
            Radiobutton.indicator  -sticky {}
        }
    }
    ttk::style map Wx.TRadiobutton -focusthickness [list focus 0]

    set f [ttk::frame .cfg.n.f1]
    ttk::labelframe $f.f2 -text "Location Selection"

    ttk::label $f.f2.l0  -text "Current"  -justify center
    ttk::label $f.f2.l0b -text "Forecast" -justify center

    ttk::label $f.f2.l1 -text "Station ID:"
    ttk::radiobutton $f.f2.r1  -variable tmpConfig(SearchType)   -value S -style Wx.TRadiobutton
    ttk::radiobutton $f.f2.r1b -variable tmpConfig(SearchTypeFc) -value S -style Wx.TRadiobutton
    ttk::entry $f.f2.e1  -textvariable tmpConfig(StationID)   -width 8 -justify center
    ttk::entry $f.f2.e1b -textvariable tmpConfig(StationIDFc) -width 8 -justify center
    clipmenu $f.f2.e1
    clipmenu $f.f2.e1b

    ttk::label $f.f2.l2 -text "ZipCode:"
    ttk::radiobutton $f.f2.r2  -variable tmpConfig(SearchType)   -value Z -style Wx.TRadiobutton
    ttk::radiobutton $f.f2.r2b -variable tmpConfig(SearchTypeFc) -value Z -style Wx.TRadiobutton
    ttk::entry $f.f2.e2  -textvariable tmpConfig(ZipCode)   -width 8 -justify center
    ttk::entry $f.f2.e2b -textvariable tmpConfig(ZipCodeFc) -width 8 -justify center
    clipmenu $f.f2.e2
    clipmenu $f.f2.e2b

    ttk::label $f.f2.l4 -text "Latitude:"
    ttk::radiobutton $f.f2.r4  -variable tmpConfig(SearchType)   -value L -style Wx.TRadiobutton
    ttk::radiobutton $f.f2.r4b -variable tmpConfig(SearchTypeFc) -value L -style Wx.TRadiobutton
    ttk::entry $f.f2.e4  -textvariable tmpConfig(Latitude)   -width 8 -justify center
    ttk::entry $f.f2.e4b -textvariable tmpConfig(LatitudeFc) -width 8 -justify center
    clipmenu $f.f2.e4
    clipmenu $f.f2.e4b
    ttk::label $f.f2.l5 -text "Longitude:"
    ttk::entry $f.f2.e5  -textvariable tmpConfig(Longitude)   -width 8 -justify center
    ttk::entry $f.f2.e5b -textvariable tmpConfig(LongitudeFc) -width 8 -justify center
    clipmenu $f.f2.e5
    clipmenu $f.f2.e5b

    ttk::label $f.f2.l6 -text "Use HV User Location"
    ttk::radiobutton $f.f2.r6  -variable tmpConfig(SearchType)   -value H -style Wx.TRadiobutton
    ttk::radiobutton $f.f2.r6b -variable tmpConfig(SearchTypeFc) -value H -style Wx.TRadiobutton

    ttk::checkbutton $f.f2.c1 -text "Use Current Weather values for Forecasts" \
        -variable tmpConfig(LocSelection) -command [list enabledatasource .cfg.n]
    ttk::button $f.f2.b1 -text "Map Current\nReporting Station" -width 0 -command [list mapstation C]
    ttk::button $f.f2.b2 -text "Map Forecast\nReporting Station" -width 0 -command [list mapstation F]

    grid    x     $f.f2.l0    -     $f.f2.l0b    -                 -padx 4 -pady 4
    grid $f.f2.l1 $f.f2.e1 $f.f2.r1 $f.f2.r1b $f.f2.e1b -sticky ew -padx 4 -pady 4
    grid $f.f2.l2 $f.f2.e2 $f.f2.r2 $f.f2.r2b $f.f2.e2b -sticky ew -padx 4 -pady 4
#   grid $f.f2.l3 $f.f2.e3 $f.f2.r3 $f.f2.r3b $f.f2.e3b -sticky ew -padx 4 -pady 4
    grid $f.f2.l4 $f.f2.e4 $f.f2.r4 $f.f2.r4b $f.f2.e4b -sticky ew -padx 4 -pady {4 0}
    grid $f.f2.l5 $f.f2.e5    x        x      $f.f2.e5b -sticky ew -padx 4 -pady {0 4}
    grid $f.f2.l6    -     $f.f2.r6 $f.f2.r6b           -sticky ew -padx 4 -pady 4
    grid anchor $f.f2 center
    grid    x     $f.f2.c1    -        -         -      -sticky ew
    grid    x     $f.f2.b1    x        x      $f.f2.b2  -sticky ew

    ttk::frame $f.f6
    ttk::button $f.f6.b1 -text "Get Stations" -width 0 -command cfg_stations
    grid $f.f6.b1 -sticky we -padx 5

    grid $f.f2 -sticky ew -padx 8 -pady 4
    grid $f.f6 -sticky w  -padx 8 -pady 4

    grid columnconfigure $f $f.f2  -weight 1
    grid columnconfigure $f.f2 all -weight 1

    .cfg.n add $f -text "Stations" -underline 0

    set f [ttk::frame .cfg.n.f2]
    ttk::labelframe $f.f3 -text "Current Weather"
    ttk::radiobutton $f.f3.r0 -text "None" \
        -variable tmpConfig(WeatherType) -value N \
        -command [list enabledatasource .cfg.n]
    ttk::radiobutton $f.f3.r1 -text "NWS " \
        -variable tmpConfig(WeatherType) -value X \
        -command [list enabledatasource .cfg.n]
    ttk::radiobutton $f.f3.r2 -text "METAR" \
        -variable tmpConfig(WeatherType) -value M \
        -command [list enabledatasource .cfg.n]
   ttk::radiobutton $f.f3.r3 -text "OpenWeather" \
       -variable tmpConfig(WeatherType) -value W \
       -command [list enabledatasource .cfg.n]
   grid $f.f3.r0 $f.f3.r1 $f.f3.r2 $f.f3.r3 -sticky w -padx 4 -pady {8 6}
    grid $f.f3.r0 $f.f3.r1 $f.f3.r2 -sticky w -padx 4 -pady {8 6}

    ttk::labelframe $f.f2 -text "Forecast Weather"
    ttk::radiobutton $f.f2.r1 -text "None" \
        -variable tmpConfig(ForecastEnable) -value N \
        -command [list enabledatasource .cfg.n]
    ttk::radiobutton $f.f2.r2 -text "NWS" \
        -variable tmpConfig(ForecastEnable) -value X \
        -command [list enabledatasource .cfg.n]
    ttk::radiobutton $f.f2.r3 -text "OpenWeather" \
        -variable tmpConfig(ForecastEnable) -value W \
        -command [list enabledatasource .cfg.n]
    grid $f.f2.r1 $f.f2.r2 $f.f2.r3 -sticky ew -padx 4 -pady {8 6}
    grid $f.f2.r1 $f.f2.r2 -sticky ew -padx 4 -pady {8 6}

    ttk::labelframe $f.f4 -text "Source"
    ttk::frame $f.f4.f
    ttk::radiobutton $f.f4.f.r4 -text "Web" \
        -variable tmpConfig(DataSource) -value Web \
        -command [list enabledatasource .cfg.n]
    ttk::radiobutton $f.f4.f.r5 -text "File" \
        -variable tmpConfig(DataSource) -value File \
        -command [list enabledatasource .cfg.n]
    ttk::button $f.f4.b1 -text "Edit Web and File Links" -width 0 -command cfg_links
    grid $f.f4.f.r4 $f.f4.f.r5 -sticky w -padx 4 -pady 0
    grid $f.f4.f  -column 0 -row 0 -sticky w -padx 4 -pady {8 6}
    grid $f.f4.b1 -column 1 -row 0 -sticky e -padx 4 -pady {2 2}
    grid columnconfigure $f.f4 all -weight 1

    ttk::labelframe $f.f6 -text OpenWeather
    ttk::frame $f.f6.f1
    ttk::label $f.f6.f1.l1 -text "API Key:" -anchor w
    ttk::entry $f.f6.f1.e1 -textvariable tmpConfig(ConsumerKey) -width 40 \
        -validate key -validatecommand {validate_cust_key %P}
    clipmenu $f.f6.f1.e1
    grid $f.f6.f1.l1 $f.f6.f1.e1 -sticky we -padx 5

    ttk::frame $f.f6.f2
    ttk::label $f.f6.f2.l2 -text "Icon Type:" -anchor w
    ttk::label $f.f6.f2.l3 -text "Forecast" -anchor e
    ttk::label $f.f6.f2.l4 -text "Current" -anchor e
    ttk::radiobutton $f.f6.f2.r3 -text "Standard" \
        -variable tmpConfig(IconsizeC) -value "" \
        -command [list removeicons]
    ttk::radiobutton $f.f6.f2.r4 -text "2X" \
        -variable tmpConfig(IconsizeC) -value "@2x" \
        -command [list removeicons]
     ttk::radiobutton $f.f6.f2.r4a -text "4X" \
        -variable tmpConfig(IconsizeC) -value @4x \
        -command [list removeicons]
   ttk::radiobutton $f.f6.f2.r5 -text "Standard" \
        -variable tmpConfig(IconsizeF) -value "" \
        -command [list removeicons]
    ttk::radiobutton $f.f6.f2.r6 -text "2X" \
        -variable tmpConfig(IconsizeF) -value "@2x" \
        -command [list removeicons]
    ttk::radiobutton $f.f6.f2.r6a -text "4X" \
        -variable tmpConfig(IconsizeF) -value "@4x" \
        -command [list removeicons]

    grid $f.f6.f2.l2              -sticky we -padx 5
    grid x $f.f6.f2.l4 $f.f6.f2.r3 $f.f6.f2.r4 $f.f6.f2.r4a -sticky we -padx 5
    grid x $f.f6.f2.l3 $f.f6.f2.r5 $f.f6.f2.r6 $f.f6.f2.r6a -sticky we -padx 5 -pady {3 3}

    grid $f.f6.f1 -sticky we -padx 5 -pady {0 5}
    grid $f.f6.f2 -sticky we -padx 5

    grid $f.f3 -sticky we -padx 8 -pady 4
    grid $f.f2 -sticky we -padx 8 -pady 4
    grid $f.f4 -sticky we -padx 8 -pady 4
    grid $f.f6 -sticky we -padx 8 -pady 4
    grid columnconfigure $f all -weight 1

    .cfg.n add $f -text "Data Source" -underline 0

    set f [ttk::frame .cfg.n.f3]
    ttk::labelframe $f.f2 -text "Fetch Control"
    ttk::checkbutton $f.f2.c1 -text "Enable Fetch" \
        -variable tmpConfig(ReadEnable) \
        -command [list enablefetch .cfg.n]
    ttk::frame $f.f2.f
    ttk::label $f.f2.f.l1 -text "Read Interval (minutes):"
    ttk::spinbox $f.f2.f.e1 -textvariable tmpConfig(ReadTime) -width 5 -justify center \
        -from 0 -to 9995  -increment 5 -wrap 1
    clipmenu $f.f2.f.e1

    grid $f.f2.f.l1 $f.f2.f.e1 -padx 2 -pady 0
    grid $f.f2.c1 -column 0 -row 0 -sticky w -padx 4     -pady {8 6}
    grid $f.f2.f  -column 1 -row 0 -sticky e -padx {0 4} -pady {8 6}
    grid columnconfigure $f.f2 all -weight 1

    ttk::labelframe $f.f1 -text "Units"
    ttk::label $f.f1.l4 -text "Time Format:"
    ttk::radiobutton $f.f1.r10 -text "12-hour" \
        -variable tmpConfig(TimeFormat) -value U
    ttk::radiobutton $f.f1.r11 -text "24-hour" \
        -variable tmpConfig(TimeFormat) -value E
    ttk::radiobutton $f.f1.r12 -text "HV Pref" \
        -variable tmpConfig(TimeFormat) -value H

    grid $f.f1.l4 $f.f1.r10 $f.f1.r11 $f.f1.r12 -sticky w -padx 6 -pady {2 0}

    ttk::label $f.f1.l1 -text "Temp Scale:"
    ttk::radiobutton $f.f1.r1 -text "Fahrenheit" \
        -variable tmpConfig(TempScale) -value F
    ttk::radiobutton $f.f1.r2 -text "Celsius" \
        -variable tmpConfig(TempScale) -value C
    ttk::radiobutton $f.f1.r2b -text "HV Pref" \
        -variable tmpConfig(TempScale) -value H

    grid $f.f1.l1 $f.f1.r1 $f.f1.r2 $f.f1.r2b -sticky w -padx 6 -pady 10

    ttk::label $f.f1.l2 -text "Wind Speed:"
    ttk::radiobutton $f.f1.r3 -text "Miles per Hour" \
        -variable tmpConfig(SpeedScale) -value M
    ttk::radiobutton $f.f1.r4 -text "KM per Hour" \
        -variable tmpConfig(SpeedScale) -value K
    ttk::radiobutton $f.f1.r5 -text "Knots" \
        -variable tmpConfig(SpeedScale) -value N
    ttk::radiobutton $f.f1.r6 -text "Beaufort" \
        -variable tmpConfig(SpeedScale) -value B

    grid $f.f1.l2 $f.f1.r3 $f.f1.r4 $f.f1.r5 -sticky w -padx 6
    grid    x     $f.f1.r6                   -sticky w -padx 6

    ttk::label $f.f1.l3 -text "Pressure:"
    ttk::radiobutton $f.f1.r7 -text "Inches" \
        -variable tmpConfig(PressureScale) -value I
    ttk::radiobutton $f.f1.r8 -text "Millibars" \
        -variable tmpConfig(PressureScale) -value M
    ttk::radiobutton $f.f1.r9 -text "Millimeters" \
        -variable tmpConfig(PressureScale) -value C

    grid $f.f1.l3 $f.f1.r7 $f.f1.r8 $f.f1.r9 -sticky w -padx 6 -pady 10

    ttk::labelframe $f.f3 -text "Forecast Settings"
    ttk::label $f.f3.l1 -text "Line Length" -anchor e
    ttk::spinbox $f.f3.e1 -textvariable tmpConfig(LineLength) -width 6 -justify center \
        -from 5 -to 200 -increment 10 -wrap 1
    clipmenu $f.f3.e1
    ttk::label $f.f3.l2 -text "Prob. of Precip. (hours from now)" -anchor e
    ttk::spinbox $f.f3.e2 -textvariable tmpConfig(PopPeriod)  -width 6 -justify center \
        -from 1 -to 168 -increment 6 -wrap 1
    clipmenu $f.f3.e2
    ttk::label $f.f3.l3 -text "Language" -anchor e
    ttk::combobox $f.f3.s1 -textvariable tmpConfig(Language) -justify center -width 15
    $f.f3.s1 state readonly
    $f.f3.s1 configure -values [dict keys $LanguageVals]
    grid $f.f3.l1 $f.f3.e1 -padx 4 -pady 4 -sticky ew
    grid $f.f3.l2 $f.f3.e2 -padx 4 -pady 4 -sticky ew
    grid $f.f3.l3 $f.f3.s1 -padx 4 -pady 4 -sticky ew

    grid $f.f2 -padx 8 -pady 4 -sticky ew
    grid $f.f1 -padx 8 -pady 4 -sticky ew
    grid $f.f3 -padx 8 -pady 4 -sticky ew
    grid columnconfigure $f all -weight 1

    .cfg.n add $f -text "General Settings" -underline 0

    set f [ttk::frame .cfg.n.f5]
    ttk::labelframe $f.f5 -text "Enable"
    ttk::radiobutton $f.f5.r7 -text "Never" \
        -variable tmpConfig(SpeechEnable) -value 0 \
        -command [list enablespeech $f]
    ttk::radiobutton $f.f5.r8 -text "Always" \
        -variable tmpConfig(SpeechEnable) -value 1 \
        -command [list enablespeech $f]
    ttk::radiobutton $f.f5.r9 -text "Serial Cmd Only" \
        -variable tmpConfig(SpeechEnable) -value 2 \
        -command [list enablespeech $f]

    grid $f.f5.r7 $f.f5.r8 $f.f5.r9 -sticky w -padx 4 -pady {8 6}

    ttk::labelframe $f.f6 -text "Weather Items to Speak"
    ttk::frame $f.f6.f2
    ttk::label $f.f6.f2.t -text "Inactive Items"
    ttk::frame $f.f6.f2.f1 -style TEntry -borderwidth 2
    listbox $f.f6.f2.f1.l  -width 20 -height 11 -highlightthickness 0 -relief flat \
        -listvariable SpeakInactive \
        -yscrollcommand [list $f.f6.f2.f1.s set] -selectmode extended -exportselection 0
    ttk::scrollbar $f.f6.f2.f1.s -command [list $f.f6.f2.f1.l yview]

    grid $f.f6.f2.f1.l $f.f6.f2.f1.s -sticky news
    grid columnconfigure $f.f6.f2.f1 0 -weight 1
    grid rowconfigure    $f.f6.f2.f1 0 -weight 1
    grid $f.f6.f2.t  -sticky n
    grid $f.f6.f2.f1 -sticky n

    ttk::frame $f.f6.f1
    ttk::button $f.f6.f1.b1 -image [imglist addarrow] \
        -state disabled -command [list speechadd $f]
    ttk::button $f.f6.f1.b2 -image [imglist removearrow] \
        -state disabled -command [list speechdelete $f]

    grid $f.f6.f1.b1 -sticky n -pady 10
    grid $f.f6.f1.b2 -sticky n -pady 10

    ttk::frame $f.f6.f3
    ttk::label $f.f6.f3.t -text "Active Items"
    ttk::frame $f.f6.f3.f1 -style TEntry -borderwidth 2
    listbox $f.f6.f3.f1.l  -width 20 -height 11 -highlightthickness 0 -relief flat \
        -listvariable SpeakActive \
        -yscrollcommand [list $f.f6.f3.f1.s set] -selectmode extended -exportselection 0
    ttk::scrollbar $f.f6.f3.f1.s -command [list $f.f6.f3.f1.l yview]

    grid $f.f6.f3.f1.l $f.f6.f3.f1.s -sticky news
    grid columnconfigure $f.f6.f3.f1 0 -weight 1
    grid rowconfigure    $f.f6.f3.f1 0 -weight 1
    grid $f.f6.f3.t  -sticky n
    grid $f.f6.f3.f1 -sticky n

    bind $f.f6.f2.f1.l <Double-1> [list $f.f6.f1.b1 invoke]
    bind $f.f6.f3.f1.l <Double-1> [list $f.f6.f1.b2 invoke]
    bind $f.f6.f2.f1.l <<ListboxSelect>> [list selspeech $f.f6.f1.b1 %W]
    bind $f.f6.f3.f1.l <<ListboxSelect>> [list selspeech $f.f6.f1.b2 %W]

    ttk::frame $f.f6.f4
    ttk::button $f.f6.f4.b1 -image [imglist uparrow] \
        -state disabled -command [list speechup $f]
    ttk::button $f.f6.f4.b2 -image [imglist downarrow] \
        -state disabled -command [list speechdown $f]

    grid $f.f6.f4.b1 $f.f6.f4.b2 -padx 5

    grid $f.f6.f2 $f.f6.f1 $f.f6.f3 -padx 8 -pady 4
    grid    x        x     $f.f6.f4 -padx 4 -pady 4

    grid $f.f5 -sticky ew -padx 8 -pady 4
    grid $f.f6 -sticky ew -padx 8 -pady 4
    grid columnconfigure $f.f6 all -weight 1
    grid columnconfigure $f    all -weight 1

    .cfg.n add $f -text "Speech" -underline 1

    set f [ttk::frame .cfg.n.f6]
    ttk::labelframe $f.f2 -text "HomeVision Controller Weather Variable Update"
    ttk::checkbutton $f.f2.c1 -text "Enable Update" \
        -variable tmpConfig(HVWeatherEnable) \
        -command [list enablehvwxvars $f.f2]
    ttk::label $f.f2.l2 -text "Temp., Wind, Humidity & Pressure, plus:" \
        -anchor center

    ttk::label $f.f2.c2 \
        -text "Store Weather Condition ($HVVarSize(HVWeatherVar))" -anchor e
    ttk::combobox $f.f2.cb2 -state readonly -width 28
    bind $f.f2.cb2 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb2 HVWeatherVar]

    ttk::label $f.f2.c3 \
        -text "Store Observation Time ($HVVarSize(HVObsTimeVar))" -anchor e
    ttk::combobox $f.f2.cb3 -state readonly -width 28
    bind $f.f2.cb3 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb3 HVObsTimeVar]

    ttk::label $f.f2.c4 \
        -text "Store Observation Date ($HVVarSize(HVObsDateVar))" -anchor e
    ttk::combobox $f.f2.cb4 -state readonly -width 28
    bind $f.f2.cb4 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb4 HVObsDateVar]

    ttk::label $f.f2.c5 \
        -text "Store Station ID ($HVVarSize(HVStationIDVar))" -anchor e
    ttk::combobox $f.f2.cb5 -state readonly -width 28
    bind $f.f2.cb5 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb5 HVStationIDVar]

    ttk::label $f.f2.c6 \
        -text "Store Prob. of Precip. ($HVVarSize(HVPoPVar))" -anchor e
    ttk::combobox $f.f2.cb6 -state readonly -width 28
    bind $f.f2.cb6 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb6 HVPoPVar]

    ttk::label $f.f2.c7 \
        -text "Store Cloud Cover ($HVVarSize(HVCloudVar))" -anchor e
    ttk::combobox $f.f2.cb7 -state readonly -width 28
    bind $f.f2.cb7 <<ComboboxSelected>> [list selhvwxvar $f.f2.cb7 HVCloudVar]

    grid $f.f2.c1 $f.f2.l2  -sticky ew -padx 4
    grid $f.f2.c2 $f.f2.cb2 -sticky ew -padx 8 -pady 4
    grid $f.f2.c3 $f.f2.cb3 -sticky ew -padx 8 -pady 4
    grid $f.f2.c4 $f.f2.cb4 -sticky ew -padx 8 -pady 4
    grid $f.f2.c5 $f.f2.cb5 -sticky ew -padx 8 -pady 4
    grid $f.f2.c6 $f.f2.cb6 -sticky ew -padx 8 -pady 4
    grid $f.f2.c7 $f.f2.cb7 -sticky ew -padx 8 -pady 4

    grid $f.f2 -sticky news -padx 8 -pady 4
    grid columnconfigure $f all -weight 1

    .cfg.n add $f -text "HV Vars" -underline 0

    set f [ttk::frame .cfg.n.f7]
    ttk::labelframe $f.f5 -text "Control Variable Type"
    ttk::radiobutton $f.f5.r7 -text "Current" \
        -variable WxFcEnable -value "C" \
        -command [list ctlvarinit $f]
    ttk::radiobutton $f.f5.r8 -text "Forecast" \
        -variable WxFcEnable -value "F" \
        -command [list ctlvarinit $f]
    ttk::radiobutton $f.f5.r9 -text "Control" \
        -variable CtlWebEnable -value "C" \
        -command [list ctlvarinit $f]
    ttk::radiobutton $f.f5.r10 -text "Web" \
        -variable CtlWebEnable -value "W" \
        -command [list ctlvarinit $f]
    ttk::radiobutton $f.f5.r11 -text "MQTT" \
        -variable CtlWebEnable -value "M" \
        -command [list ctlvarinit $f]

    ttk::label $f.f5.l -text "        "

    grid $f.f5.r7 $f.f5.r8 $f.f5.l $f.f5.r9 $f.f5.r10 $f.f5.r11 -padx 4 -pady {8 6}
    grid columnconfigure $f.f5 {0 1 2 3 4} -uniform ALL

    ttk::labelframe $f.f6 -text "Control Variables"
    ttk::frame $f.f6.f2
    ttk::label $f.f6.f2.t -text "Inactive Variables"
    ttk::frame $f.f6.f2.f1 -style TEntry -borderwidth 2
    listbox $f.f6.f2.f1.l  -width 20 -height 11 -highlightthickness 0 -relief flat \
        -listvariable CtlVarInactive \
        -yscrollcommand [list $f.f6.f2.f1.s set] -selectmode extended -exportselection 0
    ttk::scrollbar $f.f6.f2.f1.s -command [list $f.f6.f2.f1.l yview]

    grid $f.f6.f2.f1.l $f.f6.f2.f1.s -sticky news
    grid columnconfigure $f.f6.f2.f1 0 -weight 1
    grid rowconfigure    $f.f6.f2.f1 0 -weight 1
    grid $f.f6.f2.t  -sticky n
    grid $f.f6.f2.f1 -sticky n

    ttk::frame $f.f6.f1
    ttk::button $f.f6.f1.b1 -image [imglist addarrow] \
        -state disabled -command [list ctlvaradd $f]
    ttk::button $f.f6.f1.b2 -image [imglist removearrow] \
        -state disabled -command [list ctlvardelete $f]

    grid $f.f6.f1.b1 -sticky n -pady 10
    grid $f.f6.f1.b2 -sticky n -pady 10

    ttk::frame $f.f6.f3
    ttk::label $f.f6.f3.t  -text "Active Variables"
    ttk::frame $f.f6.f3.f1 -style TEntry -borderwidth 2
    listbox $f.f6.f3.f1.l  -width 20 -height 11 -highlightthickness 0 -relief flat \
        -listvariable CtlVarActive \
        -yscrollcommand [list $f.f6.f3.f1.s set] -selectmode extended -exportselection 0
    ttk::scrollbar $f.f6.f3.f1.s -command [list $f.f6.f3.f1.l yview]

    ttk::labelframe $f.f7 -text "MQTT Settings"
    ttk::label $f.f7.l1 -text "State Topic:"
    ttk::label $f.f7.l2 -text "Command Topic:"
    ttk::entry $f.f7.e1 -textvariable tmpConfig(StateTopic) -width 40
    ttk::entry $f.f7.e2 -textvariable tmpConfig(CmndTopic) -width 40
    ttk::checkbutton $f.f7.c1 -text "Set Retain Flag" -variable tmpConfig(MqttRetain)

    grid $f.f7.l1 $f.f7.e1 $f.f7.c1
    grid $f.f7.l2 $f.f7.e2

    grid $f.f6.f3.f1.l $f.f6.f3.f1.s -sticky news
    grid columnconfigure $f.f6.f3.f1 0 -weight 1
    grid rowconfigure    $f.f6.f3.f1 0 -weight 1
    grid $f.f6.f3.t  -sticky n
    grid $f.f6.f3.f1 -sticky n

    bind $f.f6.f2.f1.l <Double-1> [list $f.f6.f1.b1 invoke]
    bind $f.f6.f3.f1.l <Double-1> [list $f.f6.f1.b2 invoke]
    bind $f.f6.f2.f1.l <<ListboxSelect>> [list selctlvar $f.f6.f1.b1 %W]
    bind $f.f6.f3.f1.l <<ListboxSelect>> [list selctlvar $f.f6.f1.b2 %W]

    grid $f.f6.f2 $f.f6.f1 $f.f6.f3  -padx 8 -pady 4
    grid $f.f6.f2 $f.f6.f1 $f.f6.f3  -padx 8 -pady 4
    grid $f.f5 -sticky  ew  -padx 8 -pady 4
    grid $f.f6 -sticky news -padx 8 -pady 4
    grid $f.f7 -sticky news -padx 8 -pady 4
    grid rowconfigure    $f     1  -weight 1
    grid columnconfigure $f.f6 all -weight 1
    grid columnconfigure $f    all -weight 1

    .cfg.n add $f -text "Ctrl/Web/MQTT Vars" -underline 0
    bind .cfg.n <<NotebookTabChanged>> {cfg_help %W}

    ttk::frame  .cfg.bf
    ttk::button .cfg.bf.b1 -text OK     -image [imglist ok] \
        -compound left -width 8 -command {validateentry}
    ttk::button .cfg.bf.b2 -text Cancel -image [imglist cancel] \
        -compound left -width 8 -command {cfgexit}
    ttk::label .cfg.bf.b3 -width 5 -anchor center
    if {$tmpConfig(StickyConfig) == 0} {
        .cfg.bf.b3 configure -text ""
    } else {
        .cfg.bf.b3 configure -text "S"
    }
    grid .cfg.bf.b1 .cfg.bf.b3 .cfg.bf.b2 -padx 20 -pady 8 -sticky news
    grid columnconfigure .cfg.bf {0 2} -weight 1 -uniform 1
    grid columnconfigure .cfg.bf {1} -weight 0

    grid .cfg.n  -sticky n
    grid .cfg.bf -sticky s -pady 5

    bind .cfg <F2> {stickycfg}
    wm protocol .cfg WM_DELETE_WINDOW cfgexit
    center .cfg

    enablefetch      .cfg.n
    enablehvwxvars   .cfg.n.f6.f2
    enabledatasource .cfg.n
    speechinit       .cfg.n.f5
    enablespeech     .cfg.n.f5
    ctlvarinit       .cfg.n.f7

    if {[regexp {\+-?[0-9]+\+-?[0-9]+} $tmpConfig(Geometry) loc]} {
        wm geometry .cfg $loc
    }
    if {$type != 0} {
#        .cfg.n select .cfg.n.f2
    }
    if {$tmpConfig(CurrentTab) ne ""} {
        .cfg.n select $tmpConfig(CurrentTab)
    }
    wm deiconify .cfg

}

#! Configure stations
proc cfg_stations {} {
    global tStationID tmpConfig Stationlist

    set tStationID $tmpConfig(StationID)

    destroy       .cfg.sta
    ttk::toplevel .cfg.sta
    wm title      .cfg.sta "Get NWS Stations"
    wm resizable  .cfg.sta 0 0
    wm transient  .cfg.sta .cfg
    wm withdraw   .cfg.sta

    set f [ttk::frame .cfg.sta.f]
    ttk::label $f.l7 -text "State/Region:" -anchor w
    ttk::combobox $f.e7 -textvariable tmpConfig(StateCurrent) -width 6
    clipmenu $f.e7
    bind $f.e7 <<ComboboxSelected>> [list getstationlist $f]
    bind $f.e7 <Return> [list getstationlist $f]
    ttk::label $f.l3 -text "Station ID:" -anchor w
    ttk::entry $f.e3 -textvariable tStationID -width 6
    bind $f.e3 <Return> [list getstationlist $f]
    clipmenu $f.e3
    ttk::label $f.l4b -text "\n"
    ttk::label $f.l4  -text "Station Name:" -anchor nw
    ttk::label $f.l4a -textvariable tmpConfig(StationNameCurrent) \
        -justify left -anchor nw -wraplength 200  -width 35
    ttk::label $f.l5  -foreground red -textvariable FetchMsg -anchor c
    ttk::button $f.b1 -text "Retrieve\nStations" -width 0 -command [list stationupdate $f]
    ttk::checkbutton $f.c1 -text "Retrieve\nShort List" -variable tmpConfig(ShortStationList)
    ttk::checkbutton $f.c2 -text "Show Hidden\nStations" -variable tmpConfig(ShowStations)  \
         -command [list getstationlist .cfg.sta.f]

    ttk::frame $f.f2 -style TEntry -borderwidth 2
    listbox $f.f2.l  -width 35 -height 10 -highlightthickness 0 -relief flat \
        -listvariable Stationlist  \
        -yscrollcommand [list $f.f2.s set] -selectmode extended -exportselection 0
    ttk::scrollbar $f.f2.s -command [list $f.f2.l yview]
    bind $f.f2.l <<ListboxSelect>> [list selstation $f]
   hidemenu $f.f2.l

    grid $f.f2.l $f.f2.s -sticky news
    grid columnconfigure $f.f2 0 -weight 1
    grid rowconfigure $f.f2 0 -weight 1

    ttk::button $f.b4 -text "Map Selected\nStation" -width 0 -command [list mapstation S]
    ttk::frame $f.f3
    ttk::button $f.f3.b1 -text "Copy to\nCurrent" -width 0 -command [list selstation $f C]
    ttk::button $f.f3.b2 -text "Copy to\nForecast" -width 0 -command [list selstation $f F]
    ttk::button $f.f3.b3 -text "Copy to\nBoth" -width 0 -command [list selstation $f {C F}]

    grid $f.f3.b1 $f.f3.b2 $f.f3.b3 -padx 4 -pady 4 -ipadx 8

    ttk::separator $f.sep

    ttk::button $f.bok -text OK -image [imglist ok] \
        -compound left -width 8 -command {cfg_station_exit}

    grid $f.l7 $f.e7  -sticky w    -padx 4 -pady 4
    grid $f.l3 $f.e3  -sticky w    -padx 4 -pady 4
    grid   x   $f.l4b -sticky nw   -padx 4 -pady 4
    grid $f.l4 $f.l4a -sticky nw   -padx 4 -pady 4 -row 2
    grid $f.l5   -    -sticky news -padx 4
    grid $f.b1 $f.f2  -sticky we   -padx 4 -pady 4
    grid $f.c1   ^    -sticky we   -padx 4 -pady 5
    grid $f.c2   ^    -sticky we   -padx 4 -pady 5
    grid $f.b4 $f.f3  -sticky we   -padx 4 -pady 5
    grid anchor $f.f3  center
    grid $f           -rowspan 1
    grid $f.sep  -    -sticky we   -padx 2 -pady {2 0}
    grid $f.bok  -                 -padx 4 -pady 5

    bind .cfg.sta <F1> {hvHelp webwx}
    center .cfg.sta .cfg
    grab   .cfg.sta

    if {$tmpConfig(LocSelection) == 0} {
        $f.f3.b2 state !disabled
        $f.f3.b3 state !disabled
    } else {
        $f.f3.b2 state disabled
        $f.f3.b3 state disabled
    }

    getstatelist   .cfg.sta.f
    getstationlist .cfg.sta.f
}

proc cfg_station_exit {} {
    stationsave
    destroy .cfg.sta
}

#! Configure web and file links
proc cfg_links {} {

    destroy       .cfg.link
    ttk::toplevel .cfg.link
    wm title      .cfg.link "Configure Web and File Links"
    wm resizable  .cfg.link 0 0
    wm transient  .cfg.link .cfg
    wm withdraw   .cfg.link

    set f .cfg.link
    ttk::frame $f.f2
    ttk::label $f.f2.l1 -text "METAR:"  -anchor w
    ttk::label $f.f2.l2 -text "Server:" -anchor w
    ttk::entry $f.f2.d  -textvariable tmpConfig(FTPServer) -width 20
    clipmenu $f.f2.d

    ttk::label $f.f2.l3 -text "Dir:" -anchor w
    ttk::entry $f.f2.e  -textvariable tmpConfig(FTPDir) -width 30
    clipmenu $f.f2.e
    grid $f.f2.l1 x x x -padx 3  -sticky n
    grid $f.f2.l2 $f.f2.d $f.f2.l3 $f.f2.e -sticky w -padx 3

    ttk::frame $f.f3
    ttk::label $f.f3.l7 -text "NWS Current:" -anchor w
    ttk::entry $f.f3.d  -textvariable tmpConfig(WebLink) -width 47
    clipmenu $f.f3.d
    ttk::label $f.f3.l8 -text "NWS Forecast:" -anchor w
    ttk::entry $f.f3.db -textvariable tmpConfig(WebLinkFc)
    clipmenu $f.f3.db
    grid $f.f3.l7  $f.f3.d  -sticky we -padx 4 -pady 0
    grid $f.f3.l8 $f.f3.db  -sticky we -padx 4 -pady {4 0}

    ttk::label $f.f3.l4 -text "OpenWeather:" -anchor w
    ttk::entry $f.f3.e1 -textvariable tmpConfig(WebLinkWb)
    clipmenu $f.f3.e1
    ttk::label $f.f3.l3 -text "OpenWeather Icons:" -anchor w
    ttk::entry $f.f3.e3 -textvariable tmpConfig(WebLinkWbIcons)
    clipmenu $f.f3.e3
    grid $f.f3.l4  $f.f3.e1 -sticky we -padx 4 -pady {4 4}
    grid $f.f3.l3  $f.f3.e3 -sticky we -padx 4 -pady {0 19}

    ttk::label $f.f3.l5 -text "Current Weather File:" -anchor w
    ttk::entry $f.f3.e  -textvariable tmpConfig(FileSource)
    clipmenu $f.f3.e
    ttk::button $f.f3.b -text ... -width 3 -command [list browseFile "FileSource"]
    grid $f.f3.l5 $f.f3.e $f.f3.b  -sticky we -padx 5 -pady 0

    ttk::label $f.f3.l6 -text "Forecast File:" -anchor w
    ttk::entry $f.f3.e2 -textvariable tmpConfig(FileSourceFc)
    clipmenu $f.f3.e2
    ttk::button $f.f3.b2 -text ... -width 3 -command [list browseFile "FileSourceFc"]
    grid $f.f3.l6 $f.f3.e2 $f.f3.b2 -sticky we -padx 5 -pady 0

    ttk::label $f.f3.l9 -text "Map URL:\nUse <lat>,<lon>" -anchor w
    ttk::entry $f.f3.e5 -textvariable tmpConfig(MapLink)
    clipmenu $f.f3.e5
    grid $f.f3.l9 $f.f3.e5 -sticky we -padx 5 -pady 0

    ttk::frame $f.f4
    ttk::button $f.f4.bre -text "Restore to Defaults" \
          -command cfg_link_defaults
    grid $f.f4.bre -sticky we -padx 4 -pady 3

    ttk::separator .cfg.link.sep

    ttk::button .cfg.link.bok -text OK -image [imglist ok] \
        -compound left -width 8 -command cfg_link_done

    grid $f.f2  -sticky we -padx 2
    grid $f.f3  -sticky we -padx 2 -pady {20 10}
    grid $f.f4  -sticky we -padx 2 -pady {10 20}
    grid $f.sep -sticky we -padx 2 -pady {2 0}
    grid $f.bok            -padx 4 -pady 3
    grid columnconfigure $f.f3 1 -weight 1

    bind $f <F1> {hvHelp webwx}
    center $f .cfg
    grab   $f
}

proc cfg_link_defaults {} {
    global tmpConfig linkConfig
    
    set answer [tk_messageBox -message "Are you sure you want to set Links to defaults?" \
            -icon question -type yesno -default no \
            -detail "If \"Yes\", current Link settings will be lost."]
    switch -- $answer {
        yes {
            foreach link [array names linkConfig] {
                set tmpConfig($link) $linkConfig($link)
            }
        }
        no  {
            return
        }
    }
}

proc cfg_link_done {} {
    destroy .cfg.link
}

proc validate_cust_key {e} {
    return [regexp {^[0-9a-z]+$} $e]
}

proc removeicons {{ext png}} {
return
    set files [glob -nocomplain -directory $::Icondir *.$ext]
    debug $files darkgreen
    catch {file delete {*}$files}
}

proc cfg_help {w} {
    global tmpConfig
    
    switch -- [$w tab [$w select] -text] {
        "Stations" -
        "Data Source" -
        "General Settings" {set help webwx}
        "Speech"           {set help speechwx}
        "HV Vars"          {set help hvwxvars}
        "Ctrl/Web Vars"    {set help controlvars}
        default            {set help index}
    }
    bind .cfg <F1> [list hvHelp $help]
    set tmpConfig(CurrentTab) [$w index current]
}

#! Set up Speech Lists
proc speechinit {w} {
    global SpeakInactive SpeakActive Spcfg

    set SpeakInactive {}
    set SpeakActive {}

    foreach n [lsort -dictionary [dict keys $Spcfg]] {
        set sci [dict get $Spcfg $n enable]
        if {$sci > 0} {
            set ac($sci) $n
        } else {
            lappend SpeakInactive $n
        }
    }
    foreach n [lsort -integer [array names ac]] {
        lappend SpeakActive $ac($n)
    }
}

#! Move speech item to active list
proc speechadd {w} {
    global tmpConfig Spcfg

    set cs [$w.f6.f2.f1.l curselection]
    if {$cs != ""} {
        set ni [$w.f6.f3.f1.l index end]
        foreach x $cs {
            set name [$w.f6.f2.f1.l get $x]
            dict set Spcfg $name enable [incr ni]
        }
        speechinit $w
    }
}

#! Move speech item to inactive list
proc speechdelete {w} {
    global tmpConfig Spcfg

    set cs [$w.f6.f3.f1.l curselection]
    if {$cs != ""} {
        foreach x $cs {
            set name [$w.f6.f3.f1.l get $x]
            dict set Spcfg $name enable 0
        }
        # renumber remaining active tags
        foreach n [dict keys $Spcfg] {
            set sci [dict get $Spcfg $n enable]
            if {$sci != 0} {
                set ac($sci) $n
            }
        }
        set i 1
        foreach n [lsort -integer [array names ac]] {
            dict set Spcfg $ac($n) enable $i
            incr i
        }
        speechinit $w
    }
}

#! Move speech item up in active list
proc speechup {w} {
    global Spcfg

    set cs [lindex [$w.f6.f3.f1.l curselection] 0]
    if {$cs != ""} {
        if {$cs > 0} {
            set cs1 [format "%x" $cs]
            set cs2 [format "%x" [expr {$cs + 1}]]
            set i1 [$w.f6.f3.f1.l get [expr {$cs - 1}]]
            set i2 [$w.f6.f3.f1.l get $cs]
            dict set Spcfg $i1 enable $cs2
            dict set Spcfg $i2 enable $cs1
            speechinit $w
            $w.f6.f3.f1.l selection set [expr {$cs - 1}]
        }
    }
}

#! Move speech item down in active list
proc speechdown {w} {
    global Spcfg

    set cs [lindex [$w.f6.f3.f1.l curselection] 0]
    if {$cs != ""} {
        if {$cs < [$w.f6.f3.f1.l index end] - 1} {
            set cs1 [format "%x" [expr {$cs + 1}]]
            set cs2 [format "%x" [expr {$cs + 2}]]
            set i1 [$w.f6.f3.f1.l get $cs]
            set i2 [$w.f6.f3.f1.l get [expr {$cs + 1}]]
            dict set Spcfg $i1 enable $cs2
            dict set Spcfg $i2 enable $cs1
            speechinit $w
            $w.f6.f3.f1.l selection set [expr {$cs + 1}]
        }
    }
}

#! Enable buttons according to what was selected in Speech lists
proc selspeech {w lb} {
    if {[llength [$lb curselection]]} {
        if {".cfg.n.f5.f6.f2.f1.l" eq $lb} {
            .cfg.n.f5.f6.f1.b1 state !disabled
            .cfg.n.f5.f6.f1.b2 state  disabled
            .cfg.n.f5.f6.f4.b1 state  disabled
            .cfg.n.f5.f6.f4.b2 state  disabled
            .cfg.n.f5.f6.f3.f1.l selection clear 0 end
        } else {
            .cfg.n.f5.f6.f1.b1 state  disabled
            .cfg.n.f5.f6.f1.b2 state !disabled
            .cfg.n.f5.f6.f4.b1 state !disabled
            .cfg.n.f5.f6.f4.b2 state !disabled
            .cfg.n.f5.f6.f2.f1.l selection clear 0 end
        }
    } else {
        .cfg.n.f5.f6.f1.b1 state  disabled
        .cfg.n.f5.f6.f1.b2 state  disabled
        .cfg.n.f5.f6.f4.b1 state  disabled
        .cfg.n.f5.f6.f4.b2 state  disabled
    }
}

#! Save speech list changes to Config
proc speechsave {} {
    global tmpConfig Spcfg

    dict for {name info} $Spcfg {
        dict with info {
            set byte [expr {abs($byte)-1}]
            set flags [format {%0.2X} $enable]
            set tmpConfig(SpeechConfig) [lreplace $tmpConfig(SpeechConfig) $byte $byte $flags]
        }
    }
}

proc enablespeech {w} {
    global tmpConfig

    if {$tmpConfig(SpeechEnable)} {
        $w.f6         state !disabled
        $w.f6.f2.f1.s state !disabled
        $w.f6.f2.t    state !disabled
        $w.f6.f2.f1.l configure -state normal
        $w.f6.f3.f1.s state !disabled
        $w.f6.f3.t    state !disabled
        $w.f6.f3.f1.l configure -state normal
        if {[llength [$w.f6.f2.f1.l curselection]]} {
            $w.f6.f1.b1 state !disabled
        }
        if {[llength [$w.f6.f3.f1.l curselection]]} {
            $w.f6.f1.b2 state !disabled
            $w.f6.f4.b1 state !disabled
            $w.f6.f4.b2 state !disabled
        }
    } else {
        $w.f6 state disabled
        $w.f6.f1.b1 state disabled
        $w.f6.f1.b2 state disabled
        $w.f6.f2.f1.s state  disabled
        $w.f6.f2.t state  disabled
        $w.f6.f2.f1.l configure -state disabled
        $w.f6.f3.f1.s state  disabled
        $w.f6.f3.t state  disabled
        $w.f6.f3.f1.l configure -state disabled
        $w.f6.f4.b1 state disabled
        $w.f6.f4.b2 state disabled
    }
}

#! Data Source Configuration
proc enablefetch {w} {
    global tmpConfig

    if {$tmpConfig(ReadEnable) == 1} {
        $w tab $w.f1 -state normal
        $w tab $w.f2 -state normal
        $w tab $w.f5 -state normal
        $w tab $w.f6 -state normal
        $w tab $w.f7 -state normal
    } else {
        $w tab $w.f1 -state disabled
        $w tab $w.f2 -state disabled
        $w tab $w.f5 -state disabled
        $w tab $w.f6 -state disabled
        $w tab $w.f7 -state disabled
    }
}

proc enabledatasource {w} {
    global tmpConfig tmpLinkA

    if {$tmpConfig(ReadEnable) == 0} {return}

    if {$tmpConfig(LocSelection) == 1} {
        foreach v {StationID ZipCode Latitude Longitude} {
            set tmpConfig(${v}Fc) $tmpConfig($v)
        }
    }

    if {$tmpConfig(DataSource) eq "File"} {
        $w tab $w.f1 -state disabled
        $w.f2.f6.f1.l1 state disabled
        $w.f2.f6.f1.e1 state disabled
    } else {
        $w tab $w.f1 -state normal
        if {$tmpConfig(WeatherType) eq "W" || $tmpConfig(ForecastEnable) eq "W"} {
            $w.f2.f6.f1.l1 state !disabled
            $w.f2.f6.f1.e1 state !disabled
            $w.f2.f6.f2.l2 state !disabled
        } else {
            $w.f2.f6.f1.l1 state disabled
            $w.f2.f6.f1.e1 state disabled
            $w.f2.f6.f2.l2 state disabled
        }
        if {$tmpConfig(WeatherType) eq "W"} {
            $w.f2.f6.f2.l4 state !disabled
            $w.f2.f6.f2.r3 state !disabled
            $w.f2.f6.f2.r4 state !disabled
            $w.f2.f6.f2.r4a state !disabled
        } else {
                $w.f2.f6.f2.l4 state disabled
                $w.f2.f6.f2.r3 state disabled
                $w.f2.f6.f2.r4 state disabled
            $w.f2.f6.f2.r4a state disabled
        }
        if {$tmpConfig(ForecastEnable) eq "W"} {
                $w.f2.f6.f2.l3 state !disabled
                $w.f2.f6.f2.r5 state !disabled
                $w.f2.f6.f2.r6 state !disabled
            $w.f2.f6.f2.r6a state !disabled
        } else {
            $w.f2.f6.f2.l3 state disabled
            $w.f2.f6.f2.r5 state disabled
            $w.f2.f6.f2.r6 state disabled
            $w.f2.f6.f2.r6a state disabled
        }
        $w.f1.f2.l1 state disabled
        $w.f1.f2.r1 state disabled
        $w.f1.f2.e1 state disabled
        $w.f1.f2.l2 state disabled
        $w.f1.f2.r2 state disabled
        $w.f1.f2.e2 state disabled
        $w.f1.f2.l4 state disabled
        $w.f1.f2.r4 state disabled
        $w.f1.f2.e4 state disabled
        $w.f1.f2.l5 state disabled
        $w.f1.f2.e5 state disabled
        $w.f1.f2.l6 state disabled
        $w.f1.f2.r6 state disabled
        $w.f1.f2.r1b state disabled
        $w.f1.f2.e1b state disabled
        $w.f1.f2.r2b state disabled
        $w.f1.f2.e2b state disabled
        $w.f1.f2.r4b state disabled
        $w.f1.f2.e4b state disabled
        $w.f1.f2.e5b state disabled
        $w.f1.f2.r6b state disabled
        if {$tmpConfig(WeatherType) in {M X W}} {
            $w.f1.f2.l1 state !disabled
            $w.f1.f2.r1 state !disabled
            $w.f1.f2.e1 state !disabled
            $w.f1.f2.r2 state !disabled
            $w.f1.f2.e2 state !disabled
            $w.f1.f2.l4 state !disabled
            $w.f1.f2.r4 state !disabled
            $w.f1.f2.e4 state !disabled
            $w.f1.f2.l5 state !disabled
            $w.f1.f2.e5 state !disabled
            $w.f1.f2.l6 state !disabled
            $w.f1.f2.r6 state !disabled
        }
        if {$tmpConfig(ForecastEnable) in {X W} || $tmpConfig(WeatherType) eq "W"} {
            $w.f1.f2.l1 state !disabled
            $w.f1.f2.l2 state !disabled
            $w.f1.f2.l4 state !disabled
            $w.f1.f2.l5 state !disabled
            $w.f1.f2.l6 state !disabled
        }
        if {$tmpConfig(ForecastEnable) in {X W}} {
            $w.f1.f2.r1b state !disabled
            $w.f1.f2.r2b state !disabled
            $w.f1.f2.r4b state !disabled
            $w.f1.f2.r6b state !disabled
            if {$tmpConfig(LocSelection) == 0} {
                $w.f1.f2.e1b state !disabled
                $w.f1.f2.e2b state !disabled
                $w.f1.f2.e4b state !disabled
                $w.f1.f2.e5b state !disabled
            } else {
                $w.f1.f2.e1 state !disabled
                $w.f1.f2.e2 state !disabled
                $w.f1.f2.e4 state !disabled
                $w.f1.f2.e5 state !disabled
            }
        }

        set tmpLinkA(nwscur) \
            [format "%s/%s.xml" $tmpConfig(WebLink) $tmpConfig(StationID)]
        set tmpLinkA(station) "$tmpConfig(WebLink)/index.xml"
    }
}

#! Browse for weather files
proc browseFile {s} {
    global  tmpConfig

    set dir [file normalize [file dirname $tmpConfig($s)]]
    set f [ttk::getOpenFile -parent .cfg  -initialdir $dir \
        -title "Select Weather File"]
    if {[string length $f]} {
        set tmpConfig($s) [file normalize $f]
    }
}

#! Build state list
proc getstatelist {w} {
    global Config tmpConfig StateStations

    set list {}
    foreach s [array names StateStations] {
        lappend list $s
    }
    set alist [lsort -dictionary $list]
    $w.e7 configure -values $alist
    $w.e7 set $tmpConfig(StateCurrent)
}

#! Select a station
proc selstation {w {which "T"}} {
    global Stationlist tmpConfig tStationID

    set x [$w.f2.l curselection]
    if {[llength $x]} {
        if {"C" in $which} {
            lassign [split [lindex $Stationlist $x] ":"] \
                tmpConfig(StationID) tmpConfig(StationNameCurrent)
        }
        if {"F" in $which} {
            lassign [split [lindex $Stationlist $x] ":"] \
                tmpConfig(StationIDFc) tmpConfig(StationNameCurrent)
        }
        if {"T" in $which} {
            lassign [split [lindex $Stationlist $x] ":"] \
                tStationID tmpConfig(StationNameCurrent)
        }
    }
}

#! Create a station list
proc getstationlist {w} {
    global tmpConfig tStationID Stationlist StateStations StationNames

    set tStationID [string toupper [$w.e3 get]]
    set tmpConfig(StateCurrent) [string toupper [$w.e7 get]]
    $w.e7 set $tmpConfig(StateCurrent)

    set Stationlist {}
    set tmp 0
    if {$tmpConfig(StateCurrent) in [array names StateStations]} {
        foreach n [lsort -dictionary $StateStations($tmpConfig(StateCurrent))] {
            if {$tmpConfig(ShowStations) == 1 || $StationNames($n,hide) eq "unhide"} {
                lappend Stationlist "$n:$StationNames($n)"
                if {$n eq $tStationID} {
                    set tmp [llength $Stationlist]
                    incr tmp -1
                }
            }
        }
    }
    $w.f2.l selection set $tmp
    $w.f2.l see $tmp
}

#! Find Lat,Long for station type and map
proc mapstation {type} {
    global tStationID StationNames Wx Fx

    switch $type {
        S {
            maploc $StationNames($tStationID,lat) $StationNames($tStationID,lon)
        }
        C {
            maploc $Wx(Lat) $Wx(Long)
       }
        F {
            maploc $Fx(FcLat) $Fx(FcLong)
        }
    }
}

#! Parse url template and map
proc maploc {lat lon} {
    global Config

    set map [list <lat> $lat <lon> $lon]
    set url [string map $map $Config(MapLink)]
    debug "maploc: $url" red
    if [catch {launchBrowser $url} err] {
        debug "error $err"
    }
}

#! Launch browser with url
# Stolen from http://wiki.tcl.tk/557
proc launchBrowser url {
    global tcl_platform

    if {$tcl_platform(platform) eq "windows"} {
        set command [list {*}[auto_execok start] {}]
    } elseif {$tcl_platform(os) eq "Darwin"} {
        # It *is* generally a mistake to use $tcl_platform(os) to select functionality,
        # particularly in comparison to $tcl_platform(platform).  For now, let's just
        # regard it as a stylistic variation subject to debate.
        set command [list open]
    } else {
        set command [list xdg-open]
    }
    debug "$command;$url" red
    exec {*}$command $url &
}

#! Process a var when selected for an HV wx item
proc selhvwxvar {w type} {
    global tmpConfig
    set c [lindex [split [$w get] ":"] 0]
    if {$c eq "None" || ![valhvwxvar $type $c]} {
        set tmpConfig($type) 256
    } else {
        set tmpConfig($type) [expr {$c}]
    }
    enablehvwxvars [string range $w 0 [expr {[string last "." $w] - 1}]]
}

#! Validate selected HV wx var for overflow or overlap
proc valhvwxvar {type vval} {
    global tmpConfig HVVarSize

    set vsz $HVVarSize($type)
    if {$vval + $vsz - 1 >= [hvObjectCount var]} {
        return 0
    }

    foreach {tv} [array names HVVarSize] {
        if {$tv eq $type} {continue}
        set tsz $HVVarSize($tv)
        set tval $tmpConfig($tv)
        if {$tval > $vval + $vsz - 1} {continue}
        if {$vval > $tval + $tsz - 1} {continue}
        return 0
    }
    return 1
}

#! Create var list for HV wx drop-down boxes
proc createvarlist {widget type} {
    global  tmpConfig HVVarSize

    set cnt [hvObjectCount var]
    set val "None"
    for {set v 0; set i 1} {$v < $cnt} {incr v} {
        set brk 0
        foreach {var size} [array get HVVarSize] {
                if {$tmpConfig($var) == $v } {
                    if { $type ne "$var"} {
                            incr v [expr {$size - 1}]
                            set brk 1
                            break
                    } else {
                        set index $i
                    }
                }
        }
        if {$brk != 0} {continue}
        set name [hvObjectName var $v]
        lappend val "$v:$name"
        incr i
    }
    $widget configure -values $val
    if {[llength $val] > 1 && ($tmpConfig($type) <= $cnt - $HVVarSize($type))} {
        $widget current $index
    } else {
        $widget current 0
        set tmpConfig($type) 256
    }
}
#! refresh HV wx var lists and enable/disable widgets
proc enablehvwxvars {w} {
    global  tmpConfig

    createvarlist $w.cb2 HVWeatherVar
    createvarlist $w.cb3 HVObsTimeVar
    createvarlist $w.cb4 HVObsDateVar
    createvarlist $w.cb5 HVStationIDVar
    createvarlist $w.cb6 HVPoPVar
    createvarlist $w.cb7 HVCloudVar

    if {!$tmpConfig(HVWeatherEnable)} {
        $w.l2  state disabled
        $w.c2  state disabled
        $w.c3  state disabled
        $w.c4  state disabled
        $w.c5  state disabled
        $w.c6  state disabled
        $w.cb2 state disabled
        $w.cb3 state disabled
        $w.cb4 state disabled
        $w.cb5 state disabled
        $w.cb6 state disabled
    } else {
        $w.l2  state !disabled
        $w.c2  state !disabled
        $w.c3  state !disabled
        $w.c4  state !disabled
        $w.c5  state !disabled
        $w.c6  state !disabled
        $w.cb2 state !disabled
        $w.cb3 state !disabled
        $w.cb4 state !disabled
        $w.cb5 state !disabled
        $w.cb6 state !disabled
    }
}

#! Set up Control Variable lists
proc ctlvarinit {w} {
    global CtlVarInactive CtlVarActive WxFcEnable CtlWebEnable
    global Wxcfg Fxcfg

    set CtlVarInactive {}
    set CtlVarActive   {}
        if {$CtlWebEnable eq "C"} {
            set type "Control"
            set t    "ctl_enable"
            $w.f7 state    disabled
            $w.f7.l1 state disabled
            $w.f7.l2 state disabled
            $w.f7.e1 state disabled
            $w.f7.e2 state disabled
            $w.f7.c1 state disabled
        } elseif {$CtlWebEnable eq "W"} {
            set type "Web"
            set t    "web_enable"
            $w.f7 state    disabled
            $w.f7.l1 state disabled
            $w.f7.l2 state disabled
            $w.f7.e1 state disabled
            $w.f7.e2 state disabled
            $w.f7.c1 state disabled
        } else {
            set type "MQTT"
            set t    "mqtt_enable"
            $w.f7    state !disabled
            $w.f7.l1 state !disabled
            $w.f7.l2 state !disabled
            $w.f7.e1 state !disabled
            $w.f7.e2 state !disabled
            $w.f7.c1 state !disabled
        }

    if {$WxFcEnable eq "C"} {
        $w.f6 configure -text "Current Weather $type Variables"
        set itemlist [lsort -dictionary [dict keys $Wxcfg]]
        set d $Wxcfg
    } else {
        $w.f6 configure -text "Forecast Weather $type Variables"
        set itemlist [lsort -dictionary [dict keys $Fxcfg]]
        set d $Fxcfg
    }
    foreach n $itemlist {
        set sci [dict get $d $n $t]
        set byte [dict get $d $n byte]
        if {$byte > 0} {
            if {$sci > 0 && $byte > 0} {
                lappend CtlVarActive $n
            } else {
                lappend CtlVarInactive $n
            }
        }
    }
    $w.f6.f2.t configure -text "Inactive Variables ([llength $CtlVarInactive])"
    $w.f6.f3.t configure -text "Active Variables ([llength $CtlVarActive])"
}

#! Move Control Variable item to active list
proc ctlvaradd {w} {
    global WxFcEnable CtlWebEnable Wxcfg Fxcfg

    set cs [$w.f6.f2.f1.l curselection]
    if {$cs != ""} {
        if {$CtlWebEnable eq "C"} {
            set type "ctl_enable"
        } elseif {$CtlWebEnable eq "W"} {
            set type "web_enable"
        } else {
            set type "mqtt_enable"
        }
        debug "type:$type" red
        foreach x $cs {
            set name [$w.f6.f2.f1.l get $x]
            if {$WxFcEnable eq "C"} {
                dict set Wxcfg $name $type 1
            } else {
                dict set Fxcfg $name $type 1
            }
        }
        ctlvarinit $w
    }
}

#! Move Control Variable item to inactive list
proc ctlvardelete {w} {
    global WxFcEnable CtlWebEnable Wxcfg Fxcfg

    set cs [$w.f6.f3.f1.l curselection]
    if {$cs != ""} {
        if {$CtlWebEnable eq "C"} {
            set type "ctl_enable"
        } elseif {$CtlWebEnable eq "W"} {
            set type "web_enable"
        } else {
            set type "mqtt_enable"
        }
        foreach x $cs {
            set name [$w.f6.f3.f1.l get $x]
            if {$WxFcEnable eq "C"} {
                dict set Wxcfg $name $type 0
            } else {
                dict set Fxcfg $name $type 0
            }
        }
        ctlvarinit $w
    }
}

proc selctlvar {w lb} {
    if {[llength [$lb curselection]]} {
        if {".cfg.n.f7.f6.f2.f1.l" eq $lb} {
            .cfg.n.f7.f6.f1.b1 state !disabled
            .cfg.n.f7.f6.f1.b2 state  disabled
            .cfg.n.f7.f6.f3.f1.l selection clear 0 end
        } else {
            .cfg.n.f7.f6.f1.b1 state  disabled
            .cfg.n.f7.f6.f1.b2 state !disabled
            .cfg.n.f7.f6.f2.f1.l selection clear 0 end
        }
    } else {
        .cfg.n.f7.f6.f1.b1 state  disabled
        .cfg.n.f7.f6.f1.b2 state  disabled
    }
}

#! Save Control Variable list changes to Config
proc ctlvarsave {} {
    global tmpConfig Wxcfg Fxcfg

     dict for {name info} $Wxcfg {
        dict with info {
            set byte [expr {abs($byte)-1}]
            set flags [scan [lindex $tmpConfig(WxVarConfig) $byte] {%x}]
            if {$ctl_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(WxVarConfig) [lreplace $tmpConfig(WxVarConfig) $byte $byte $flags]

            set flags [scan [lindex $tmpConfig(WxWebConfig) $byte] {%x}]
            if {$web_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(WxWebConfig) [lreplace $tmpConfig(WxWebConfig) $byte $byte $flags]

            set flags [scan [lindex $tmpConfig(WxMqttConfig) $byte] {%x}]
            if {$mqtt_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(WxMqttConfig) [lreplace $tmpConfig(WxMqttConfig) $byte $byte $flags]
        }
    }

    dict for {name info} $Fxcfg {
        dict with info {
            set byte [expr {abs($byte)-1}]
            set flags [scan [lindex $tmpConfig(FxVarConfig) $byte] {%x}]
            if {$ctl_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(FxVarConfig) [lreplace $tmpConfig(FxVarConfig) $byte $byte $flags]

            set flags [scan [lindex $tmpConfig(FxWebConfig) $byte] {%x}]
            if {$web_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(FxWebConfig) [lreplace $tmpConfig(FxWebConfig) $byte $byte $flags]

            set flags [scan [lindex $tmpConfig(FxMqttConfig) $byte] {%x}]
            if {$mqtt_enable} {
                set flags [format {%0.2X} [expr {$flags | $bit}]]
            } else {
                set flags [format {%0.2X} [expr {$flags & ~$bit}]]
            }
            set tmpConfig(FxMqttConfig) [lreplace $tmpConfig(FxMqttConfig) $byte $byte $flags]
        }
    }
}

#! Validate configuration settings before committing
proc validateentry {} {
    global tmpConfig

    set msg {}
    if {![string is integer -strict $tmpConfig(ReadTime)] || \
            $tmpConfig(ReadTime) > 9999 || $tmpConfig(ReadTime) < 0} {
        lappend msg "Read Time must be >= 0 and <= 9999."
    }
    if {$tmpConfig(WeatherType) eq "W" || $tmpConfig(ForecastEnable) eq "W"} {
        if {![string is alnum -strict $tmpConfig(ConsumerKey)]} {
            lappend msg "Keys must be alphanumeric characters."
        }
    }
    if {$tmpConfig(SearchType) eq "S"} {
        set sp [split $tmpConfig(StationID) ,]
        lassign $sp station provider
        if {![string is alnum -strict $station] || \
                ([string length $station] != 4 && \
                 [string length $station] != 5)} {
            lappend msg "StationID must be 4-5 alphanumeric characters long"
        }
        if {[llength $sp] == 2 && ![string is digit -strict $provider] } {
            lappend msg "Check optional comma and numeric Provider ID"
        }
    } elseif {$tmpConfig(SearchType) eq "Z"} {
        if {![string match {[0-9]*} $tmpConfig(ZipCode)] || \
                [string length $tmpConfig(ZipCode)] != 5}  {
            lappend msg "Zip Code must be 5 digits."
        }
    } elseif {$tmpConfig(SearchType) eq "L"} {
        if {![string is double -strict $tmpConfig(Latitude)] || \
            $tmpConfig(Latitude) > 90 || $tmpConfig(Latitude) < -90} {
            lappend msg "Latitude must be -90 to 90"
        }
        if {![string is double -strict $tmpConfig(Longitude)] || \
            $tmpConfig(Longitude) > 180 || $tmpConfig(Longitude) < -180} {
            lappend msg "Longitude must be -180 to 180"
        }
    } elseif {$tmpConfig(SearchType) eq "H"} {
        # no action
    }
    if {$tmpConfig(SearchTypeFc) eq "S"} {
        set sp [split $tmpConfig(StationIDFc) ,]
        lassign $sp station provider
        if {![string is alnum -strict $station] || \
                ([string length $station] != 4 && \
                 [string length $station] != 5)} {
            lappend msg "StationID must be 4-5 alphanumeric characters long"
        }
        if {[llength $sp] == 2 && ![string is digit -strict $provider] } {
            lappend msg "Check optional comma and numeric Provider ID"
        }

    } elseif {$tmpConfig(SearchTypeFc) eq "Z"} {
        if {![string match {[0-9]*} $tmpConfig(ZipCodeFc)] || \
                [string length $tmpConfig(ZipCodeFc)] != 5}  {
            lappend msg "Zip Code must be 5 digits."
        }
    } elseif {$tmpConfig(SearchTypeFc) eq "L"} {
        if {![string is double -strict $tmpConfig(LatitudeFc)] || \
            $tmpConfig(LatitudeFc) > 90 || $tmpConfig(LatitudeFc) < -90} {
            lappend msg "Latitude must be -90 to 90"
        }
        if {![string is double -strict $tmpConfig(LongitudeFc)] || \
            $tmpConfig(LongitudeFc) > 180 || $tmpConfig(LongitudeFc) < -180} {
            lappend msg "Longitude must be -180 to 180"
        }
    } elseif {$tmpConfig(SearchTypeFc) eq "H"} {
        # no action
    }
    if {$tmpConfig(PopPeriod) < 1 || $tmpConfig(PopPeriod) > 168} {
        lappend msg "PoP hours must be >= 1 and <= 168."
    }
    if {![llength $msg]} {
        enabledatasource .cfg.n
        cfgexit 1
    } else {
        set msg [join $msg \n]

        destroy      .cfg.err
        toplevel     .cfg.err
        wm withdraw  .cfg.err
        wm title     .cfg.err "Configure Entry Error"
        wm resizable .cfg.err 0 0
        wm transient .cfg.err .cfg

        ttk::frame .cfg.err.f1
        ttk::label .cfg.err.f1.l1 -text $msg -anchor center

        grid .cfg.err.f1.l1 -sticky news -padx 5 -pady 5

        ttk::separator .cfg.err.sep

        ttk::frame .cfg.err.f2
        ttk::button .cfg.err.f2.b1 -text Retry  -image [imglist ok] \
        -compound left -width 8 -command {destroy .cfg.err}
        ttk::button .cfg.err.f2.b2 -text Cancel -image [imglist cancel] \
        -compound left -width 8 -command {cfgexit 0}
        grid .cfg.err.f2.b1 .cfg.err.f2.b2 -padx 20 -pady {5 8} -sticky news
        grid columnconfigure .cfg.err.f2 {0 1} -uniform buttons

        grid .cfg.err.f1  -sticky we
        grid .cfg.err.sep -sticky we
        grid .cfg.err.f2  -sticky we
        grid anchor .cfg.err.f2 center

        bind .cfg.err <F1> {hvHelp webwx}

        wm protocol .cfg.err WM_DELETE_WINDOW {.cfg.err.f2.b1 invoke}
        center .cfg.err
        grab   .cfg.err
    }
}

#! Commit (or not) configuration settings
proc cfgexit {{save 0}} {
    global Config tmpConfig
    global LinkA tmpLinkA

    if {$save} {
        ctlvarsave
        speechsave
        set tmpConfig(StationID) [string toupper $tmpConfig(StationID)]
        
        if {$Config(CmndTopic) ne $tmpConfig(CmndTopic)} {
            subscribe unsub
        }
        foreach n [array names Config] {
            set Config($n) $tmpConfig($n)
            hvConfig -keep $n $tmpConfig($n)
        }
        set tmpLinkA(wbcur) ""
        set tmpLinkA(wbfc) ""
        set tmpLinkA(wbicons) ""
        foreach n [array names LinkA] {
            set LinkA($n) $tmpLinkA($n)
        }
        init
        WeatherSetVar
    }
    if {[winfo exists .cfg]} {
        set Config(Geometry) [set geometry [wm geometry .cfg]]
        hvConfig -keep Geometry $Config(Geometry)
    }

    if {$Config(StickyConfig) == 1 && $save} {return}

    destroy .cfg
}

#! Toggle sticky bit for configuration dialog
proc stickycfg {} {
    global tmpConfig

    if {$tmpConfig(StickyConfig) == 1} {
        set tmpConfig(StickyConfig) 0
        .cfg.bf.b3 configure -text ""
    } else {
        set tmpConfig(StickyConfig) 1
        .cfg.bf.b3 configure -text "S"
    }
}

#! Create right-click editing menu for text entries
proc clipmenu {w} {
    set menu [menu $w.clipmenu -postcommand [list clipmenupost $w]]
    $menu add command -label Cut -accelerator Ctrl+X \
        -command [list event generate $w <<Cut>>]
    $menu add command -label Copy -accelerator Ctrl+C \
        -command [list event generate $w <<Copy>>]
    $menu add command -label Paste -accelerator Ctrl+V \
        -command [list event generate $w <<Paste>>]
    $menu add command -label Delete -accelerator Del \
        -command [list event generate $w <<Clear>>]
    if {[winfo class $w] eq "Text"} {
        $menu add separator
        $menu add command -label "Select All" \
            -command [list $w tag add sel 1.0 end]
        if {[$w cget -undo]} {
            $menu insert 0 separator
            $menu insert 0 command -label Undo -accelerator Ctrl+Z \
                -command [list event generate $w <<Undo>>]
        }
    }
    $w configure -exportselection 1
    bind $w <<Button3>> [list tk_popup $menu %X %Y]
}

#! Configure the clip menu
proc clipmenupost {w} {
    set menu $w.clipmenu
    # Configure the Cut, Copy and Delete entries
    switch [winfo class $w] {
        Text {set enable [llength [$w tag ranges sel]]}
        Entry - TEntry {set enable [$w selection present]}
        default {set enable 1}
    }
    if {$enable} {set state normal} else {set state disabled}
    $menu entryconfigure Cut -state $state
    $menu entryconfigure Copy -state $state
    $menu entryconfigure Delete -state $state
    # Configure the Paste entry
    if {[catch {clipboard get}]} {set state disabled} else {set state normal}
    $menu entryconfigure Paste -state $state
    if {[winfo class $w] ne "Text" || ![$w cget -undo]} return
    # Configure the Undo entry
    if {[$w edit modified]} {set state normal} else {set state disabled}
    $menu entryconfigure Undo -state $state
}

#! Create right-click hide menu for Station List
proc hidemenu {w} {
    set hmenu [menu $w.hidemenu -postcommand [list hidemenupost $w]]
    $hmenu add command -label Hide \
        -command [list hidestation $w hide]
    $hmenu add command -label Unhide \
        -command [list hidestation $w unhide]
    $hmenu add command -label Delete \
        -command [list hidestation $w delete]
    $w configure -exportselection 1
    bind $w <<Button3>> [list tk_popup $hmenu %X %Y]
}

#! Select hide or unhide in hide menu depending on station state
proc hidemenupost {w} {
    global Stationlist StationNames

    set hmenu $w.hidemenu
    set x [$w curselection]
    if {[llength $x]} {
        lassign [split [lindex $Stationlist [lindex $x 0]] ":"] stationid
        switch $StationNames($stationid,hide) {
            hide {
                $hmenu entryconfigure Hide   -state disabled
                $hmenu entryconfigure Unhide -state normal
                $hmenu entryconfigure Delete -state normal
            }
            unhide {
                $hmenu entryconfigure Hide   -state normal
                $hmenu entryconfigure Unhide -state disabled
                $hmenu entryconfigure Delete -state normal
            }
            delete {
                $hmenu entryconfigure Hide   -state normal
                $hmenu entryconfigure Unhide -state normal
                $hmenu entryconfigure Delete -state disabled
            }
        }
    }
}

#! Hide or unhide station in Station List
proc hidestation {w hide} {
    global Stationlist StationNames

    set x [$w curselection]
    foreach x [$w curselection] {
        lassign [split [lindex $Stationlist $x] ":"] stationid
        set StationNames($stationid,hide) $hide
    }
    getstationlist .cfg.sta.f
}

#! Get images for Configuration dialog
proc imglist {i} {
    global img

    if {![info exists img($i)]} {
        set img($i) [image create photo \
            -file [file join [hvVariable ImagePath] $i.png]]
        set img([format %sdim $i]) [image create photo -format {png -alpha 0.3} \
            -file [file join [hvVariable ImagePath] $i.png]]
    }
    set dim $img([format %sdim $i])
    return [list $img($i) disabled $dim]
}
# End Configuration

package require http
package require tls 1.5.1-1.41
::http::register https 443 [list ::tls::socket -tls1 1]
package require tdom
package require json 1.0

#! Download weather data
proc downloadhttp {type link now {loop 5}} {
    if {$now == 0} {
        if {[catch {::http::geturl $link \
                    -headers {Pragma no-cache Cache-Control no-cache} \
                    -command [list httpCB $type $now $loop]} token]} {
            return -code error $token
        }
        ::http::wait $token
    } else {
        if {[catch {::http::geturl $link \
                    -headers {Pragma no-cache Cache-Control no-cache}} token]} {
            debug "downloadhttp error: $type, $now, $loop, $token" red
            return -code error $token
        } else {
#            debug "run now" green
            httpCB $type $now $loop $token
        }
    }
}

#! Callback function to process weather web data
proc httpCB {type now loop token} {

    if {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] == 200 } {
        set data [::http::data $token]
        if {[catch {parseXML$type data} rl]} {
            wxfail Parse $type $rl $data
        }
    } elseif {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] in {301 302 303}} {
        set nurls [getredirecturl $token]
        incr loop -1
        debug "Try:$loop;$nurls" blue
        ::http::cleanup $token
        if {$loop > 0} {
            if {[catch {downloadhttp $type $nurls $now $loop} token]} {
                wxfail "Fetch" $type $token
            }
        }
    } else {
        wxfail Read $type "[::http::status $token]; [::http::code $token]; " [::http::data $token]
    }
    ::http::cleanup $token
}

#! Callback function to process weather file data
proc fileCBall {type link} {
    global Config

    if {![file isfile $link]} {
        wxfail "Open" "File,$type" "No File"
        return
    }
    if {![catch {open $link r} f]} {
        set data [read -nonewline $f]
        set station [file rootname [file tail $link]]
        if {$type eq "cur" } {
            if {$Config(WeatherType) eq "X"} {
                if {[catch {parseXMLnwscur data} rl]} {
                    wxfail Parse "Filenwscur" $rl  $data
                }
            } elseif {$Config(WeatherType) eq "W"} {
                validatewb
                if {[catch {parseXMLwbcur data} rl]} {
                    wxfail Parse "Filewbcur" $rl $data
                }
            } elseif {$Config(WeatherType) eq "M"} {
                if {[catch {parseMETARnwscur $data $station} rl]} {
                    wxfail Parse FileMETAR $rl $data
                }
            }
        } else {
            if {$Config(ForecastEnable) eq "X"} {
                if {[catch {parseXMLnwsfc data} rl]} {
                    wxfail Parse "Filenwsfc" $rl $data
                }
            } elseif {$Config(ForecastEnable) eq "W"} {
                validatewb
                if {[catch {parseXMLwbfc data} rl]} {
                    wxfail Parse "Filewbfc" $rl $data
                }
            }
        }
    } else {
        wxfail "Open" "File,$type" $f
    }
    catch {close $f}
}

#! Procedure to process fetch/parsing failures
proc wxfail {type source reason {data ""}} {
    global Fxcfg Wxcfg

    if {[string match -nocase "fc" [string range $source end-1 end]]} {
        if {[dict get $Fxcfg FcFetchStatus ctl_enable]} {
            ControlSetVar FcFetchStatus [clock format [clock seconds] \
                -format "Failed $type $source [timedatefmt]"]
        }
    } elseif {$source ni {STATION Icon}} {
        if {[dict get $Wxcfg FetchStatus ctl_enable]} {
            ControlSetVar FetchStatus [clock format [clock seconds] \
                -format "Failed $type $source [timedatefmt]"]
        }
    }
    debug [clock format [clock seconds] \
        -format "Failed $type $source [timedatefmt]; \
                 Reason: $reason"] red

    wxlog $type $source $reason $data
}

proc wxlog {type source reason data} {
    global Config

    if {$Config(StickyConfig) != 1} {return}

    set file [file join weather wx.log]
    if {[catch {hvConfigFile create $file a} f]} {
        debug "create error: $f"
        return
    }
    set time [clock format [clock seconds] -format "[timedatefmt]"]
    puts $f [format "%s: %s,%s: %s" $time $type $source $reason]
    if {$data ne ""} {puts $f $data}

    catch {close $f}
}

#! Set up links
proc validatewb {} {
    global LinkA Config
    set LinkA(wbcur) [format $LinkA(wbcurproto) $Config(ConsumerKey)]
    set LinkA(wbfc) [format $LinkA(wbfcproto) $Config(ConsumerKey)]
    set LinkA(wbicons) [format $LinkA(wbiconsproto) $Config(ConsumerKey)]

    debug "Link wbcur: $LinkA(wbcur)" red
    debug "Link wbfc: $LinkA(wbfc)" red
}

#! Parsing procedure for NWS forecast
#  tdom portion extensively borrowed from
#  noaa.tcl by Keith Vetter, January 2007
#  http://wiki.tcl.tk/17514
proc parseXMLnwsfc {d} {
    global Fx Fxcfg Config LinkA
    upvar 1 $d xml

    debug "parseXMLnwsfc" blue

    if {[string trim $xml] eq ""} {return -code error "No Data"}

    initfxdata $xml

    if {[catch {dom parse $xml doc}]} {
        return -code error "Bad reply from NOAA"
    }
    set root [$doc documentElement]

    if {[set node [$root selectNodes /error]] ne ""} {
        return -code error "Error reply from NOAA"
    }

    set node [$root selectNodes /dwml/head/product/creation-date]
    set value [[$node firstChild] data]
    set ot $value

    set node [$root selectNodes /dwml/data/location/point]
    set lat [$node getAttribute latitude ""]
    set long [$node getAttribute longitude ""]

    set nodes [$root selectNodes /dwml/data/time-layout]
    foreach node $nodes {
        set key [[$node selectNodes layout-key/text()] data]
        set seq 1
        foreach start [$node selectNodes start-valid-time] \
                end   [$node selectNodes end-valid-time] {
            set name ""
            set etime ""

            if {[$start hasAttribute period-name]} {
                set name [$start getAttribute period-name "???"]
            }
            set stime [[$start firstChild] data]
            if {$end ne ""} {
                set etime [[$end firstChild] data]
            }

            dict set layouts $key $seq date  $stime
            dict set layouts $key $seq edate $etime
            dict set layouts $key $seq name  $name
            incr seq
        }
    }

    set nodes [$root selectNodes /dwml/data/parameters/temperature]
    foreach node $nodes {
        if {$node eq ""} {continue}
        set type [$node getAttribute type]
        set units [$node getAttribute units]
        set key [$node getAttribute time-layout]
        set tempkeys($type) $key
        set tempscale [string index $units 0]
        set seq 1
        foreach vnode [$node selectNodes value] {
            if {$vnode eq ""} {continue}
            set temp ""
            if {[$vnode hasChildNodes]} {
                set temp [[$vnode firstChild] data]
                if {[tempscale] eq "C" && $tempscale eq "F"} {
                    set temp [expr {round(0.556 * ($temp - 32))}]
                }
                if {[tempscale] eq "F" && $tempscale eq "C"} {
                    set temp [expr {round((1.8 * $temp) + 32)}]
                }
            }
            dict set layouts $key $seq temp $temp
            incr seq
        }
    }

    set node [$root selectNodes /dwml/data/parameters/probability-of-precipitation]
    if {$node ne ""} {
        set key [$node getAttribute time-layout]
        set seq 1
        foreach vnode [$node selectNodes value] {
            if {$vnode eq ""} {continue}
            set pop ""
            if {[$vnode hasChildNodes]} {
                set pop [[$vnode firstChild] data]
            }
            dict set layouts $key $seq pop $pop
            incr seq
        }
    }

    set node [$root selectNodes /dwml/data/parameters/weather]
    if {$node ne ""} {
        set key [$node getAttribute time-layout]
        set mkey $key
        set seq 1
        foreach vnode [$node selectNodes weather-conditions] {
            if {$vnode eq ""} {continue}
            set wxs [$vnode getAttribute weather-summary ""]
            set wxs [wrap [string map {&amp;deg; " " &deg; " "} $wxs] $Config(LineLength)]
            dict set layouts $key $seq wxshort $wxs
            incr seq
        }
    }

    set node [$root selectNodes /dwml/data/parameters/conditions-icon]
    if {$node ne ""} {
        set key [$node getAttribute time-layout]
        set seq 1
        foreach inode [$node selectNodes icon-link] {
            if {$inode eq ""} {continue}
            set url ""
            if {[$inode hasChildNodes]} {
                set url [[$inode firstChild] data]
            }
            dict set layouts $key $seq icon $url
            incr seq
        }
    }

    $doc delete

    set seq 1
    set length 7
    if {[info exists mkey] && $mkey ne ""} {
        dict for {num info} [dict get $layouts $mkey] {
            unset -nocomplain date edate name pop wxshort icon
            dict with  info {
                if {![info exists date]}    {continue}
                set temp [gettemp $layouts $tempkeys(maximum) $date]
                if {$temp eq "--"} {
                    set temp [gettemp $layouts $tempkeys(minimum) $date]
                }
                if {[regexp -nocase "night" $name]} {
                    set nseq "n$seq"
                    set hl "Lo$seq"
                    incr seq
                } else {
                    set nseq "$seq"
                    set hl "Hi$seq"
                }
                if {$icon ne ""} {
                    set Fx(FcDay$nseq) $name
                    set Fx(Fc$hl) $temp
                    set Fx(FcLc$nseq) $wxshort
                    set Fx(FcSc$nseq) $wxshort
                    set Fx(FcPop$nseq) $pop
                    set Fx(FcImg$nseq) [file tail $icon]
                    lappend icons $icon
                } else {
                    set Fx(FcDay$nseq) $name
                    set Fx(Fc$hl) "--"
                    set Fx(FcLc$nseq) ""
                    set Fx(FcSc$nseq) ""
                    set Fx(FcPop$nseq) ""
                    set Fx(FcImg$nseq) ""
                }
            }
            if {$seq > $length} {break}
        }

        set Fx(FcIconBase) [string range [lindex $icons 0] 0 [string last "/" [lindex $icons 0]]]
        downloadicon fc $icons

        set time [clock add [clock seconds] $Config(PopPeriod) hours]
        dict for {num info} [dict get $layouts $mkey] {
            dict with  info {
                set start [clock scan \
                    "[string range $date 0 18] [string range $date 19 21][string range $date 23 24]" \
                    -format "%Y-%m-%dT%H:%M:%S %z"]
                set end [clock scan \
                    "[string range $edate 0 18] [string range $edate 19 21][string range $edate 23 24]" \
                    -format "%Y-%m-%dT%H:%M:%S %z"]
                if {$time >= $start && $time <= $end} {break}
            }
            unset -nocomplain date edate name pop wxshort icon
        }
    }
    set city [geonames $lat $long]
    if {[dict size $city]} {
        set Fx(FcCountry) [dict get $city countryCode]
        set Fx(FcState) [dict get $city adminName1]
        set Fx(FcCity) [dict get $city name]

        set Fx(FcLoc) $Fx(FcCity)
        if {$Fx(FcState) ne ""} {
            append Fx(FcLoc) ", $Fx(FcState)"
        }
        if {$Fx(FcCountry) ne ""} {
            append Fx(FcLoc) ", $Fx(FcCountry)"
        }
    }
    set Fx(FcLat) $lat
    set Fx(FcLong) $long

    set tm [clock scan $ot -format "%Y-%N-%eT%k:%M:%S%z"]
    set ot [clock format $tm -format [timedatefmt]]
    set Fx(FcTime) $ot
    debug $ot

    debug [clock format [clock seconds] \
        -format "Forecast Fetched [timedatefmt]"]
    set Fx(FcFetch) [clock format [clock seconds] \
        -format "[timedatefmt]"]
    set Fx(FcFetchStatus) "Succeeded"

    debug "Forecast for $Fx(FcLoc):" blue
    varset Fx Fxcfg
    if {![info exists pop]} {set pop 255}
    sethvwxvars pop $pop

    fcweb
    fcmqtt
}

#! Parsing procedure for OpenWeather forecast
proc parseXMLwbfc {d} {
    global Fx Fxcfg Config LinkA
    upvar 1 $d data

    debug "parseXMLwbfc" blue

    if {[string trim $data] eq ""} {return -code error "No Data"}
    
    initfxdata $data

    if {[catch {::json::json2dict $data} wxfc]} {
        debug $wxfc
        return -code error "Bad reply from OpenWeather.org"
    }

    set daily [dict get $wxfc daily]
    set icons ""
    for {set day 1; set i 0; set dn ""} {$day <= 7} {incr i; incr day} {
        set dayi [lindex $daily $i]
#debug "dayi:$dayi" red
        set dname [clock format [getwxitem $dayi dt "NA"] -format %a]
        set Fx(FcDay$day) $dname
        set Fx(FcDayn$day) [append dname " Night"]
        set Fx(FcPop$day) [expr {round([getwxitem $dayi pop]*100)}]
        set Fx(FcPopn$day) $Fx(FcPop$day)
        set Fx(FcUvi$day) [getwxitem $dayi uvi]
        set Fx(FcUvin$day) [getwxitem $dayi uvi]
        set Fx(FcClouds$day) [getwxitem $dayi clouds]
        set Fx(FcHumidity$day) [getwxitem $dayi humidity]
        set Fx(FcDewpoint$day) [getwxitem $dayi dew_point]
        
        set Fx(FcPressureMb$day) [getwxitem $dayi pressure]
        set Fx(FcPressureIn$day) [format "%.2f" [expr {$Fx(FcPressureMb$day)/33.864}]]
        set Fx(FcPressureMm$day) [format "%.1f" [expr {0.750062 * $Fx(FcPressureMb$day)}]]
        set wind_degrees [getwxitem $dayi wind_deg "NA"]
        set wind_speed [getwxitem $dayi wind_speed "NA"]
        set wind_gust [getwxitem $dayi wind_gust "NA"]
        if {[tempscale] == "C"} {
            if {$wind_speed ne "NA"} {
                set wind_speed [expr {3.6*$wind_speed}]
            }
            if {$wind_gust ne "NA"} {
                set wind_gust [expr {3.6*$wind_gust}]
            }
        }
        parse_wind "" [expr {[isknown $wind_degrees]?$wind_degrees:"///"}] \
                      [expr {[isknown $wind_speed]?$wind_speed:"//"}] \
                      [expr {[isknown $wind_gust]?"G$wind_gust":{}}] \
                      [expr {[tempscale] eq "F"?"MPH":"KMH"}] $day Fx

        set Fx(FcSunRise$day) \
            [clock format [getwxitem $dayi sunrise "NA"] -format "[timefmt]"]
        set Fx(FcSunSet$day) \
            [clock format [getwxitem $dayi sunset "NA"] -format "[timefmt]"]
        set Fx(FcMoonRise$day) \
            [clock format [getwxitem $dayi moonrise "NA"] -format "[timefmt]"]
        set Fx(FcMoonSet$day) \
            [clock format [getwxitem $dayi moonset "NA"] -format "[timefmt]"]
        set Fx(FcMoonPhase$day) [getwxitem $dayi moon_phase NA]
        if {![isknown $Fx(FcMoonPhase$day)]} {
            set Fx(FcMoonPhase$day) ""
        } elseif {$Fx(FcMoonPhase$day) == 0 || $Fx(FcMoonPhase$day) == 1} {
            set Fx(FcMoonPhase$day) "New Moon"
        } elseif {$Fx(FcMoonPhase$day) < 0.25} {
            set Fx(FcMoonPhase$day) "Waxing Crescent"
        } elseif {$Fx(FcMoonPhase$day) == 0.25} {
            set Fx(FcMoonPhase$day) "First Quarter Moon"
        } elseif {$Fx(FcMoonPhase$day) < 0.5} {
            set Fx(FcMoonPhase$day) "Waxing Gibbous"
        } elseif {$Fx(FcMoonPhase$day) == 0.5} {
            set Fx(FcMoonPhase$day) "Full Moon"
        } elseif {$Fx(FcMoonPhase$day) < 0.75} {
            set Fx(FcMoonPhase$day) "Waning Gibbous"
        } elseif {$Fx(FcMoonPhase$day) == 0.75} {
            set Fx(FcMoonPhase$day) "Last Quarter Moon"
        } elseif {$Fx(FcMoonPhase$day) < 1} {
            set Fx(FcMoonPhase$day) "Waning Crescent"
        }

        set dayit [join [dict get $dayi temp]]
        set Fx(FcHi$day) [getwxitemrnd $dayit max]
        set Fx(FcLo$day) [getwxitemrnd $dayit min]
        set Fx(FcTempDay$day) [getwxitemrnd $dayit day]
        set Fx(FcTempNight$day) [getwxitemrnd $dayit night]
        set Fx(FcTempEve$day) [getwxitemrnd $dayit eve]
        set Fx(FcTempMorn$day) [getwxitemrnd $dayit morn]
        set Fx(FcTempDay$day) [getwxitemrnd $dayit day]

        set dayif [join [dict get $dayi feels_like]]
#debug "dayif:$dayif" red
        set Fx(FcFLDay$day) [getwxitemrnd $dayif day]
        set Fx(FcFLLo$day) [getwxitemrnd $dayif day]
        set Fx(FcFLHi$day) [getwxitemrnd $dayif day]
        foreach fl {night eve morn} {
            set type [string totitle $fl]
            set temp [getwxitemrnd $dayif $fl]
            set Fx(FcFL$type$day) $temp
            if {$Fx(FcFLHi$day) < $temp} {
                set Fx(FcFLHi$day) $temp
            }
            if {$Fx(FcFLLo$day) > $temp} {
                set Fx(FcFLLo$day) $temp
            }
        }

        set dayiw [join [dict get $dayi weather]]
#debug "dayiw:$dayiw" red
        set Fx(FcSc$day) [getwxitem $dayiw id]
        set Fx(FcScn$day) [getwxitem $dayiw id]
        set Fx(FcLc$day) \
            [wrap [string map {&amp;deg; " " &deg; " "} [string totitle [getwxitem $dayiw description]]] $Config(LineLength)]
        set Fx(FcLcn$day) $Fx(FcLc$day)

        set icon [getwxitem $dayiw icon "999"]
#debug "icon:$icon" green
        if {$icon ne "999"} {
            set Fx(FcImg$day) $icon$Config(IconsizeF)$::Iconext
            set Fx(FcImgn$day) $Fx(FcImg$day)
           lappend icons $Fx(FcImg$day)
        }
    }

    if {$day == 0} {return -code error "Empty Data"}

    set Fx(FcIconBase) $Config(WebLinkWbIcons)
    if {[llength $icon] > 0} {
        downloadiconwb fc $icons
    }

    set lat [dict get $wxfc lat]
    set lon [dict get $wxfc lon]
#    debug "lat:$lat,long:$lon" red
    set city [geonames $lat $lon]
    if {[dict size $city]} {
        set Fx(FcCountry) [dict get $city countryCode]
        set Fx(FcState) [dict get $city adminName1]
        set Fx(FcCity) [dict get $city name]

        set Fx(FcLoc) $Fx(FcCity)
        if {$Fx(FcState) ne ""} {
            append Fx(FcLoc) ", $Fx(FcState)"
        }
        if {$Fx(FcCountry) ne ""} {
            append Fx(FcLoc) ", $Fx(FcCountry)"
        }
    }
    set Fx(FcLat) $lat
    set Fx(FcLong) $lon

    set current [dict get $wxfc current]
    set ot [getwxitem $current dt]
    set ot [clock format $ot -format [timedatefmt]]
    set Fx(FcTime) $ot
#    debug $ot

    debug [clock format [clock seconds] \
        -format "Forecast Fetched [timedatefmt]"] blue
    set Fx(FcFetch) [clock format [clock seconds] \
        -format "[timedatefmt]"]
    set Fx(FcFetchStatus) "Succeeded"

    debug "Forecast for $Fx(FcLoc):" blue
    varset Fx Fxcfg
    
    # Get pop for pop period
    set time [clock add [clock seconds] $Config(PopPeriod) hours]
    set period [expr {[clock scan 00:00] + 86400}]
    for {set i 1} {$i < 8} {incr i} {
        if {$time <= $period} {break}
        set period [expr {$period + 86400}]
    }
    if {$i > 7} {
        sethvwxvars pop 255
    } else {
        sethvwxvars pop $Fx(FcPop$i)
    }

    fcweb
    fcmqtt
}

#! Parsing procedure for OpenWeather current weather
proc parseXMLwbcur {d} {
    global Wx Config LinkA Cvar getMode
    upvar 1 $d data

    debug "parseXMLwbcur" blue

    if {[string trim $data] eq ""} {return -code error "No Data"}

    initwxdata $data $Config(StationID)

    if {[catch {::json::json2dict $data} jsonr]} {
        debug $jsonr
        return -code error "Bad reply from OpenWeather.org"
    }
    debug $jsonr blue

    set json [dict get $jsonr current]

#    set Wx(Station) [getwxitem $json stationId "NA"]
    set station $Wx(Station)

    set Wx(Uvi) [getwxitem $json uvi "NA"]
    set Wx(Clouds) [getwxitem $json clouds "NA"]
    set Wx(Humidity) [getwxitem $json humidity "NA"]
    set Wx(PressureMb) [getwxitem $json pressure "NA"]
    set Wx(FeelsLike) [getwxitem $json feels_like "NA"]
#   Open Weather uses Temp setting to determine
#   imperial (MPH) or metric (m/s) units.
#   If metric, convert m/s to KPH.
#   wxpostprocess takes care of calculating the remaining values.
    set temp [getwxitem $json temp "NA"]
    set dew_point [getwxitem $json dew_point "NA"]
    set wind_degrees [getwxitem $json wind_deg "NA"]
    set wind_speed [getwxitem $json wind_speed "NA"]
    set wind_gust [getwxitem $json wind_gust "NA"]
    if {[tempscale] == "F"} {
        set Wx(TempF) $temp
        set Wx(DewPointF) $dew_point
    } else {
        set Wx(TempC) $temp
        set Wx(DewPointC) $dew_point
        if {$wind_speed ne "NA"} {
            set wind_speed [expr {3.6*$wind_speed}]
        }
        if {$wind_gust ne "NA"} {
            set wind_gust [expr {3.6*$wind_gust}]
        }
    }
    parse_wind "" [expr {[isknown $wind_degrees]?$wind_degrees:"///"}] \
                  [expr {[isknown $wind_speed]?$wind_speed:"//"}] \
                  [expr {[isknown $wind_gust]?"G$wind_gust":{}}] \
                  [expr {[tempscale] eq "F"?"MPH":"KMH"}] "" Wx

    #visibility always in meters, convert to km
    set Wx(VisibilityKm) [getwxitem $json visibility "NA"]
#    set Wx(VisibilityKm) [expr {[getwxitem $json visibility "NA"]/1000.0}]

    set gotll 0
    set lat [getwxitem $jsonr lat "NA"]
    set long [getwxitem $$jsonr lon "NA"]
    if {$lat ne "NA" && $long ne "NA"} {
        set gotll 1
    } else {
        if {[isknown $station]} {
            if {[array names StationNames -exact "$station,lat"] ne ""} {
                set lat $StationNames($station,lat)
                set long $StationNames($station,lon)
                set gotll 1
            }
        }
    }
    if {$gotll == 1} {
        set lat [format "%.3f" $lat]
        set long [format "%.3f" $long]
        set city [geonames $lat $long]
        if {[dict size $city]} {
            set Wx(Country) [dict get $city countryCode]
            set State [dict get $city adminName1]
            set City [dict get $city name]
            set Wx(Location) $City
            if {$State ne ""} {
                append Wx(Location) ", $State"
            }
            if {$Wx(Country) ne ""} {
                append Wx(Location) ", $Wx(Country)"
            }
        }
        set Wx(Lat) $lat
        set Wx(Long) $long
    } else {
        set Wx(Lat) ""
        set Wx(Long) ""
    }
#debug "$Wx(Lat),$Wx(Long)" red

    set tm [getwxitem $json sunrise "NA"]
    if {$tm eq "NA"} {
        set tm [clock seconds]
    }
    set Wx(SunRise) [clock format $tm -format "[timefmt]"]
    set tm [getwxitem $json sunset "NA"]
    if {$tm eq "NA"} {
        set tm [clock seconds]
    }
    set Wx(SunSet) [clock format $tm -format "[timefmt]"]

    set tm [getwxitem $json dt "NA"]
    if {$tm eq "NA"} {
        set tm [clock seconds]
    }
    set Wx(ObservationTime) [clock format $tm \
        -format "Last Updated on [timedatefmt]"]
    set Wx(ObservationTimerfc822) [clock format $tm \
        -format "%a, %e %b %Y %T %Z"]

    set Wx(year) [clock format $tm -format %Y]
    set Wx(month) [clock format $tm -format %m]
    set Wx(day) [clock format $tm -format %d]
    set Wx(hour) [clock format $tm -format %H]
    set Wx(minute) [clock format $tm -format %M]
    set Wx(time-zone) [clock format $tm -format %z]
    debug "$Wx(ObservationTime)"

 #   set Wx(IconBase) [string range $icons 0 [string last "/" $icons]]

    set jsonw [dict get $json weather]
    set jsonw [join $jsonw]
    set icon [getwxitem $jsonw icon "01d"]
    if {$icon eq "null"} {
        set icon "01d"
    }
    set Wx(WeatherIcon) [format {%s%s.png} $icon $Config(IconsizeC)]
    set Wx(Weather) [string totitle [dict get $jsonw description]]
    set Wx(WeatherId) [dict get $jsonw id]
    
    wxpostprocess
    downloadiconwb wx $Wx(WeatherIcon)

    debug [clock format [clock seconds] \
        -format "Fetched [timedatefmt]"]
    set Wx(FetchTime) [clock format [clock seconds] \
        -format "[timedatefmt]"]
    set Wx(FetchStatus) "Succeeded"

    debug "Weather for $Wx(Station):"
    varset Wx Wxcfg
    foreach v [lsort -dictionary [array names Cvar]] {
        sethvwxvars $v $Wx($Cvar($v))
    }
    sethvwxvars pressure_rate 255
    sethvwxvars clouds $Wx(Clouds)

    wxweb
    wxmqtt
    wxspeech
    
    set f [string match {*fc*} $getMode]
    if {($Config(ForecastEnable) eq "W" && $f) && \
         $Config(LocSelection) == 1} {
        debug "Shared OW Fetch" red
    parseXMLwbfc $d
}
}

#! Parsing procedure for NWS current weather
proc parseXMLnwscur {d} {
    global Wx Config Cvar
    upvar 1 $d xml

    debug "parseXMLnwscur" blue

    if {[string trim $xml] eq ""} {return -code error "No Data"}

    initwxdata $xml $Config(StationID)

    if {[catch {dom parse $xml doc}]} {
        return -code error "Bad reply from NOAA"
    }
    set root [$doc documentElement]

    foreach i [array names Cvar] {
        set node [$root selectNodes /current_observation/$i]
        if {$node ne "" && [$node hasChildNodes]} {
            set value [[$node firstChild] data]
            set Wx($Cvar($i)) [string map {&quot; "\""} $value]
        }
    }
    $doc delete

    parse_wind "" [expr {[isknown $Wx(WindDegrees)]?$Wx(WindDegrees):$Wx(Wind) eq "Calm"?0:"///"}] \
                  [expr {[isknown $Wx(WindMPH)]?$Wx(WindMPH):$Wx(Wind) eq "Calm"?0:"//"}] \
                  [expr {[isknown $Wx(WindGustMPH)]?"G$Wx(WindGustMPH)":{}}] \
                  "MPH" "" Wx

    if {![catch {set tm [clock scan $Wx(ObservationTimerfc822) \
            -format "%a, %e %b %Y %T %Z"]}]} {
        set ot  [clock format $tm \
            -format "Last Updated on [timedatefmt]"]
        set Wx(ObservationTime) $ot
        set Wx(year) [clock format $tm -format %Y]
        set Wx(month) [clock format $tm -format %m]
        set Wx(day) [clock format $tm -format %d]
        set Wx(hour) [clock format $tm -format %H]
        set Wx(minute) [clock format $tm -format %M]
        set Wx(time-zone) [clock format $tm -format %z]
    } else {
        set ot $Wx(ObservationTime)
    }
    debug "$ot"

    if {[regexp {(.+?), ([A-Z][A-Z])} $Wx(Location) -> name state]} {
        set Config(StationNameCurrent) $name
        set Config(StateCurrent) $state
    }

    wxpostprocess
    downloadicon "" $Wx(IconBase)$Wx(WeatherIcon)

    debug [clock format [clock seconds] \
        -format "Fetched [timedatefmt]"]
    set Wx(FetchTime) [clock format [clock seconds] \
        -format "[timedatefmt]"]
    set Wx(FetchStatus) "Succeeded"

    debug "Weather for $Wx(Station):"
    varset Wx Wxcfg
    foreach v [lsort -dictionary [array names Cvar]] {
        sethvwxvars $v $Wx($Cvar($v))
    }

    wxweb
    wxmqtt
    wxspeech
}

#! Test if weather item exists then return value
proc getwxitem {dict name {default ""}} {
    if {[dict exists $dict $name]} {
        return [dict get $dict $name]
    } else {
        return $default
    }
}

proc getwxitemrnd {dict name {default ""}} {
    return [expr {round([getwxitem $dict $name $default])}]
}

#! Initialize current weather info before parsing
proc initwxdata {data stationid} {
    global Wx Wxcfg Config

    foreach {name bit byte default} {
        IconBase        1       1       "http://forecast.weather.gov/images/wtf/small/"
        Station         2       1       ""
        Location        4       1       "<unknown>"
        year            8       -1      "<unknown>"
        month           16      -1      "<unknown>"
        day             32      -1      "<unknown>"
        hour            64      -1      "<unknown>"
        minute          128     -1      "<unknown>"
        raw             1       -2      ""
        ObservationTime 2       2       "<unknown>"
        ObservationTimerfc822 4 2       "<unknown>"
        FetchTime       8       2       ""
        FetchStatus     16      2       ""
        time-zone       32      -2      "<unknown>"
        Lat             64      2       ""
        Long            128     2       ""
        Country         1       3       "<unknown>"
        Temp            2       3       "<unknown>"
        TempC           4       3       "<unknown>"
        TempF           8       3       "<unknown>"
        Dewpoint        16      3       "<unknown>"
        DewpointC       32      3       "<unknown>"
        DewpointF       64      3       "<unknown>"
        HeatIndex       128     3       "NA"
        HeatIndexC      1       4       "NA"
        HeatIndexF      2       4       "NA"
        Humidity        4       4       "<unknown>"
        Windchill       8       4       "NA"
        WindchillC      16      4       "NA"
        WindchillF      32      4       "NA"
        Pressure        64      4       "<unknown>"
        PressureIn      128     4       "<unknown>"
        PressureMb      1       5       "<unknown>"
        PressureMm      2       5       "<unknown>"
        VisibilityKm    4       5       "<unknown>"
        VisibilityMi    8       5       "<unknown>"
        Weather         16      5       "<unknown>"
        WeatherIcon     32      5       "<unknown>"
        Wind            64      5       "<unknown>"
        WindDegrees     128     5       "<unknown>"
        WindDir         1       6       "<unknown>"
        WindKTS         2       6       "<unknown>"
        WindMPH         4       6       "<unknown>"
        WindKPH         8       6       "<unknown>"
        WindGustKTS     16      6       "<unknown>"
        WindGustMPH     32      6       "<unknown>"
        WindGustKPH     64      6       "<unknown>"
        WindBft         128     6       0
        beaufortstr     1       -7      "<unknown>"
        windvarfrom     2       -7      "<unknown>"
        windvarfromstr  4       -7      "<unknown>"
        windvarto       8       -7      "<unknown>"
        windvartostr    16      -7      "<unknown>"
        cumulonimbus    32      -7      0
        toweringcumulus 64      -7      0
        corrected       128     -7      "<unknown>"
        cloudstr        1       -8      "<unknown>"
        cloudstype      2       -8      "<unknown>"
        cloudsheight    4       -8      "<unknown>"
        ZipCode         8       8       ""
        CityCode        16      -8       ""
        SearchType      32      8       ""
        SStation        64      8       "<unknown>"
        Clouds          128     8       "--"
        PressureRate    1       -9       "<unknown>"
        PressureRateIn  2       -9       "<unknown>"
        PressureRateMb  4       -9       "<unknown>"
        WeatherId       8       9       "--"
        Uvi             16      9       "--"
        FeelsLike       32      9       "--"
        SunRise         64      9       "--"
        SunSet          128     9       "--"
        
    } {
        if {$name ne "Station" || $stationid eq ""} {
        set Wx($name) $default
        }
        dict set Wxcfg $name bit $bit
        dict set Wxcfg $name byte $byte
    }
    set Wx(SStation) $stationid
    set Wx(raw) $data
    set Wx(ZipCode) $Config(ZipCode)
    set Wx(Lat) $Config(Latitude)
    set Wx(Long) $Config(Longitude)
    set Wx(SearchType) $Config(SearchType)
}

#! Initialize forecast weather info before parsing
proc initfxdata {data} {
    global Fx Fxcfg Config

    foreach {name bit byte default} {
        FcIconBase      1       1       ""
        FcCity          2       1       ""
        FcCcode         4       -1      ""
        FcState         8       1       ""
        FcZip           16      1       ""
        FcCountry       32      1       ""
        FcLoc           64      1       ""
        FcSStation      128     1       ""
        FcRaw           1       -2      ""
        FcTime          2       2       ""
        FcFetch         4       2       ""
        FcFetchStatus   8       2       ""
        FcSearchType    32      2       ""
        FcLat           64      2       ""
        FcLong          128     2       ""
        FcDay1          1       3       ""
        FcDay2          2       3       ""
        FcDay3          4       3       ""
        FcDay4          8       3       ""
        FcDay5          16      3       ""
        FcDay6          32      3       ""
        FcDay7          64      3       ""
        FcSc1           1       4       ""
        FcSc2           2       4       ""
        FcSc3           4       4       ""
        FcSc4           8       4       ""
        FcSc5           16      4       ""
        FcSc6           32      4       ""
        FcSc7           64      4       ""
        FcImg1          1       5       ""
        FcImg2          2       5       ""
        FcImg3          4       5       ""
        FcImg4          8       5       ""
        FcImg5          16      5       ""
        FcImg6          32      5       ""
        FcImg7          64      5       ""
        FcLc1           1       6       ""
        FcLc2           2       6       ""
        FcLc3           4       6       ""
        FcLc4           8       6       ""
        FcLc5           16      6       ""
        FcLc6           32      6       ""
        FcLc7           64      6       ""
        FcPop1          1       7       ""
        FcPop2          2       7       ""
        FcPop3          4       7       ""
        FcPop4          8       7       ""
        FcPop5          16      7       ""
        FcPop6          32      7       ""
        FcPop7          64      7       ""
        FcDayn1         1       8       ""
        FcDayn2         2       8       ""
        FcDayn3         4       8       ""
        FcDayn4         8       8       ""
        FcDayn5         16      8       ""
        FcDayn6         32      8       ""
        FcDayn7         64      8       ""
        FcScn1          1       9       ""
        FcScn2          2       9       ""
        FcScn3          4       9       ""
        FcScn4          8       9       ""
        FcScn5          16      9       ""
        FcScn6          32      9       ""
        FcScn7          64      9       ""
        FcImgn1         1       10      ""
        FcImgn2         2       10      ""
        FcImgn3         4       10      ""
        FcImgn4         8       10      ""
        FcImgn5         16      10      ""
        FcImgn6         32      10      ""
        FcImgn7         64      10      ""
        FcLcn1          1       11      ""
        FcLcn2          2       11      ""
        FcLcn3          4       11      ""
        FcLcn4          8       11      ""
        FcLcn5          16      11      ""
        FcLcn6          32      11      ""
        FcLcn7          64      11      ""
        FcPopn1         1       12      ""
        FcPopn2         2       12      ""
        FcPopn3         4       12      ""
        FcPopn4         8       12      ""
        FcPopn5         16      12      ""
        FcPopn6         32      12      ""
        FcPopn7         64      12      ""
        FcHi1           1       13      "--"
        FcHi2           2       13      "--"
        FcHi3           4       13      "--"
        FcHi4           8       13      "--"
        FcHi5           16      13      "--"
        FcHi6           32      13      "--"
        FcHi7           64      13      "--"
        FcLo1           1       14      "--"
        FcLo2           2       14      "--"
        FcLo3           4       14      "--"
        FcLo4           8       14      "--"
        FcLo5           16      14      "--"
        FcLo6           32      14      "--"
        FcLo7           64      14      "--"
        FcUvi1          1       15      "--"
        FcUvi2          2       15      "--"
        FcUvi3          4       15      "--"
        FcUvi4          8       15      "--"
        FcUvi5          16      15      "--"
        FcUvi6          32      15      "--"
        FcUvi7          64      15      "--"
        FcSunRise1      1       16      "--"
        FcSunRise2      2       16      "--"
        FcSunRise3      4       16      "--"
        FcSunRise4      8       16      "--"
        FcSunRise5      16      16      "--"
        FcSunRise6      32      16      "--"
        FcSunRise7      64      16      "--"
        FcSunSet1       1       17      "--"
        FcSunSet2       2       17      "--"
        FcSunSet3       4       17      "--"
        FcSunSet4       8       17      "--"
        FcSunSet5       16      17      "--"
        FcSunSet6       32      17      "--"
        FcSunSet7       64      17      "--"
        FcFLHi1         1       18      "--"
        FcFLHi2         2       18      "--"
        FcFLHi3         4       18      "--"
        FcFLHi4         8       18      "--"
        FcFLHi5         16      18      "--"
        FcFLHi6         32      18      "--"
        FcFLHi7         64      18      "--"
        FcFLLo1         1       19      "--"
        FcFLLo2         2       19      "--"
        FcFLLo3         4       19      "--"
        FcFLLo4         8       19      "--"
        FcFLLo5         16      19      "--"
        FcFLLo6         32      19      "--"
        FcFLLo7         64      19      "--"
        FcClouds1       1       20      "--"
        FcClouds2       2       20      "--"
        FcClouds3       4       20      "--"
        FcClouds4       8       20      "--"
        FcClouds5       16      20      "--"
        FcClouds6       32      20      "--"
        FcClouds7       64      20      "--"
        FcMoonRise1      1      21      "--"
        FcMoonRise2      2      21      "--"
        FcMoonRise3      4      21      "--"
        FcMoonRise4      8      21      "--"
        FcMoonRise5      16     21      "--"
        FcMoonRise6      32     21      "--"
        FcMoonRise7      64     21      "--"
        FcMoonSet1       1      22      "--"
        FcMoonSet2       2      22      "--"
        FcMoonSet3       4      22      "--"
        FcMoonSet4       8      22      "--"
        FcMoonSet5       16     22      "--"
        FcMoonSet6       32     22      "--"
        FcMoonSet7       64     22      "--"
        FcMoonPhase1     1      23      "--"
        FcMoonPhase2     2      23      "--"
        FcMoonPhase3     4      23      "--"
        FcMoonPhase4     8      23      "--"
        FcMoonPhase5     16     23      "--"
        FcMoonPhase6     32     23      "--"
        FcMoonPhase7     64     23      "--"
        FcFLDay1        1       24      "--"
        FcFLDay2        2       24      "--"
        FcFLDay3        4       24      "--"
        FcFLDay4        8       24      "--"
        FcFLDay5        16      24      "--"
        FcFLDay6        32      24      "--"
        FcFLDay7        64      24      "--"
        FcFLNight1      1       25      "--"
        FcFLNight2      2       25      "--"
        FcFLNight3      4       25      "--"
        FcFLNight4      8       25      "--"
        FcFLNight5      16      25      "--"
        FcFLNight6      32      25      "--"
        FcFLNight7      64      25      "--"
        FcFLEve1        1       26      "--"
        FcFLEve2        2       26      "--"
        FcFLEve3        4       26      "--"
        FcFLEve4        8       26      "--"
        FcFLEve5        16      26      "--"
        FcFLEve6        32      26      "--"
        FcFLEve7        64      26      "--"
        FcFLMorn1       1       27      "--"
        FcFLMorn2       2       27      "--"
        FcFLMorn3       4       27      "--"
        FcFLMorn4       8       27      "--"
        FcFLMorn5       16      27      "--"
        FcFLMorn6       32      27      "--"
        FcFLMorn7       64      27      "--"
        FcTempDay1      1       28      "--"
        FcTempDay2      2       28      "--"
        FcTempDay3      4       28      "--"
        FcTempDay4      8       28      "--"
        FcTempDay5      16      28      "--"
        FcTempDay6      32      28      "--"
        FcTempDay7      64      28      "--"
        FcTempNight1    1       29      "--"
        FcTempNight2    2       29      "--"
        FcTempNight3    4       29      "--"
        FcTempNight4    8       29      "--"
        FcTempNight5    16      29      "--"
        FcTempNight6    32      29      "--"
        FcTempNight7    64      29      "--"
        FcTempEve1      1       30      "--"
        FcTempEve2      2       30      "--"
        FcTempEve3      4       30      "--"
        FcTempEve4      8       30      "--"
        FcTempEve5      16      30      "--"
        FcTempEve6      32      30      "--"
        FcTempEve7      64      30      "--"
        FcTempMorn1     1       31      "--"
        FcTempMorn2     2       31      "--"
        FcTempMorn3     4       31      "--"
        FcTempMorn4     8       31      "--"
        FcTempMorn5     16      31      "--"
        FcTempMorn6     32      31      "--"
        FcTempMorn7     64      31      "--"
        FcHumidity1     1       32      "--"
        FcHumidity2     2       32      "--"
        FcHumidity3     4       32      "--"
        FcHumidity4     8       32      "--"
        FcHumidity5     16      32      "--"
        FcHumidity6     32      32      "--"
        FcHumidity7     64      32      "--"
        FcWind1         1       33      "--"
        FcWind2         2       33      "--"
        FcWind3         4       33      "--"
        FcWind4         8       33      "--"
        FcWind5         16      33      "--"
        FcWind6         32      33      "--"
        FcWind7         64      33      "--"
        FcWindMPH1      1       34      "--"
        FcWindMPH2      2       34      "--"
        FcWindMPH3      4       34      "--"
        FcWindMPH4      8       34      "--"
        FcWindMPH5      16      34      "--"
        FcWindMPH6      32      34      "--"
        FcWindMPH7      64      34      "--"
        FcWindKPH1      1       35      "--"
        FcWindKPH2      2       35      "--"
        FcWindKPH3      4       35      "--"
        FcWindKPH4      8       35      "--"
        FcWindKPH5      16      35      "--"
        FcWindKPH6      32      35      "--"
        FcWindKPH7      64      35      "--"
        FcWindKTS1      1       36      "--"
        FcWindKTS2      2       36      "--"
        FcWindKTS3      4       36      "--"
        FcWindKTS4      8       36      "--"
        FcWindKTS5      16      36      "--"
        FcWindKTS6      32      36      "--"
        FcWindKTS7      64      36      "--"
        FcWindDir1      1       37      "--"
        FcWindDir2      2       37      "--"
        FcWindDir3      4       37      "--"
        FcWindDir4      8       37      "--"
        FcWindDir5      16      37      "--"
        FcWindDir6      32      37      "--"
        FcWindDir7      64      37      "--"
        FcWindDegrees1  1       38      "--"
        FcWindDegrees2  2       38      "--"
        FcWindDegrees3  4       38      "--"
        FcWindDegrees4  8       38      "--"
        FcWindDegrees5  16      38      "--"
        FcWindDegrees6  32      38      "--"
        FcWindDegrees7  64      38      "--"
        FcWindGustMPH1  1       39      "--"
        FcWindGustMPH2  2       39      "--"
        FcWindGustMPH3  4       39      "--"
        FcWindGustMPH4  8       39      "--"
        FcWindGustMPH5  16      39      "--"
        FcWindGustMPH6  32      39      "--"
        FcWindGustMPH7  64      39      "--"
        FcWindGustKPH1  1       40      "--"
        FcWindGustKPH2  2       40      "--"
        FcWindGustKPH3  4       40      "--"
        FcWindGustKPH4  8       40      "--"
        FcWindGustKPH5  16      40      "--"
        FcWindGustKPH6  32      40      "--"
        FcWindGustKPH7  64      40      "--"
        FcWindGustKTS1  1       41      "--"
        FcWindGustKTS2  2       41      "--"
        FcWindGustKTS3  4       41      "--"
        FcWindGustKTS4  8       41      "--"
        FcWindGustKTS5  16      41      "--"
        FcWindGustKTS6  32      41      "--"
        FcWindGustKTS7  64      41      "--"
        FcPressureIn1   1       42      "--"
        FcPressureIn2   2       42      "--"
        FcPressureIn3   4       42      "--"
        FcPressureIn4   8       42      "--"
        FcPressureIn5   16      42      "--"
        FcPressureIn6   32      42      "--"
        FcPressureIn7   64      42      "--"
        FcPressureMb1   1       43      "--"
        FcPressureMb2   2       43      "--"
        FcPressureMb3   4       43      "--"
        FcPressureMb4   8       43      "--"
        FcPressureMb5   16      43      "--"
        FcPressureMb6   32      43      "--"
        FcPressureMb7   64      43      "--"
        FcPressureMm1   1       44      "--"
        FcPressureMm2   2       44      "--"
        FcPressureMm3   4       44      "--"
        FcPressureMm4   8       44      "--"
        FcPressureMm5   16      44      "--"
        FcPressureMm6   32      44      "--"
        FcPressureMm7   64      44      "--"
        FcDewpoint1     1       45      "--"
        FcDewpoint2     2       45      "--"
        FcDewpoint3     4       45      "--"
        FcDewpoint4     8       45      "--"
        FcDewpoint5     16      45      "--"
        FcDewpoint6     32      45      "--"
        FcDewpoint7     64      45      "--"
    } {
        set Fx($name) $default
        dict set Fxcfg $name bit $bit
        dict set Fxcfg $name byte $byte
    }
    set Fx(FcRaw) $data
    set Fx(FcLat) $Config(LatitudeFc)
    set Fx(FcLong) $Config(LongitudeFc)
    set Fx(FcZip) $Config(ZipCodeFc)
    set Fx(FcSStation) $Config(StationIDFc)
    set Fx(FcSearchType) $Config(SearchTypeFc)
}

#! Word-wrap text to fit expected widget width
#  Borrowed from Bob Gardner
proc wrap {text len} {

    regsub -all "\n" $text { } text
    incr len -1

    set out {}
    while {[string length $text] > $len} {
        # - Find position of last space in the part of the text
        #   which could a line in the result.

        # - We jump out of the loop if there is none and the whole
        #   text does not contain spaces anymore. In the latter case
        #   the rest of the text is one word longer than an intended
        #   line, we cannot avoid the longer line.

        set i [string last { } [string range $text 0 $len]]

        if {$i == -1 && [set i [string first { } $text]] == -1} {
            break
        }

        # Get the just fitting part of the text, remove any heading
        # and trailing spaces, then append it to the result string,
        # don't close it with a newline!

        append out [string trim [string range $text 0 [incr i -1]]]\n

        # Shorten the text by the length of the processed part and
        # the space used to split it, then iterate.

        set text [string range $text [incr i 2] end]
    }
    return $out$text
}

#! Get get temp matching date
proc gettemp {layouts type sdate} {
    dict for {num info} [dict get $layouts $type] {
        dict with info {
            if {$date eq $sdate} {return $temp}
        }
    }
    return "--"
}

#! downloadicon proc derived from noaa.tcl by Keith Vetter at
#  http://wiki.tcl.tk/17514
proc downloadicon {type url {loop 5}} {
    foreach {i} [lsort -unique $url] {
        set fn ""
        if {$type eq "wx"} {
#            append fn $type "_"
        }
        regexp {[^?]+} [file tail $i] file
        append fn $file
        set cacheName [file join $::Icondir $fn]
        if {[file exists $cacheName]} {
        } else {
            set i [string map {wx_ ""} $i]
            debug "dlicon:$type,$i,$cacheName,$loop" red
            catch {::http::geturl $i \
                -command [list downloadiconCB $type $i $cacheName $loop]
            } rl
        }
    }
}

#! downloadiconCB proc derived from noaa.tcl by Keith Vetter at
#  http://wiki.tcl.tk/17514
proc downloadiconCB {type url cacheName loop token} {

    if {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] == 200 } {
        set data [::http::data $token]
        catch {
            set fout [open $cacheName wb]
            puts -nonewline $fout $data
            close $fout
        }
    } elseif {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] in {301 302 303}} {
        set nurls [getredirecturl $token]
        incr loop -1
        debug "Try:$loop;$nurls" blue
        ::http::cleanup $token
        if {$loop > 0} {
            downloadicon $type $nurls $loop
        }
    } else {
        wxfail Read Icon "[::http::status $token]; [::http::ncode $token]"
    }
    ::http::cleanup $token
}

#! (download if needed) download icons
proc downloadiconwb {type code} {
    global LinkA

    set code [lsort -unique $code]

    foreach {ic} $code {
#debug "ic:$ic,code:$code" red
        downloadicon $type $LinkA(wbicons)/${ic}
    }
}

#! Get urls from html redirection response
#  Part taken from http://forum.egghelp.org/viewtopic.php?t=17615
proc getredirecturl {token} {
    upvar #0 $token state
        foreach {name value} $state(meta) {
            if {[regexp -nocase ^location$ $name]} {
                if {![string match "http*" $value]} {
                   # fix our locations if needed
                    if {![string match "/" [string index $value 0]]} {
                       set value "[join [lrange [split $url "/"] 0 2] "/"]/$nurl"
                    } else {
                       set value "[join [lrange [split $url "/"] 0 2] "/"]$nurl"
                    }
                }
                set nurl $value
#               debug "location: $nurl" red
            }
        }
        debug "redirect to: $nurl" blue
        debug "from $state(url)" blue
#       debug "status: [::http::status $token]" red
        debug "ncode: [::http::code $token]" red
#       debug "state: [array get state]" red
#       debug "meta: $state(meta)" green

    return $nurl
}

proc wxserial {cmd data} {
    global Config tmpConfig

    regexp {([^_.]+)_(.*)} $cmd -> type args
    set nummatch [string length "weather: $type $args"]
    switch $type {
        fetch {
            switch $args {
                now     {WeatherSetVar 1}
                bkgnd   {WeatherSetVar}
                disable {
                    set tmpConfig(ReadEnable) 0
                    set Config(ReadEnable) 0
                    if {[winfo exists .cfg]} {
                        enablefetch .cfg.n
                    }
                }
                enable  {
                    set tmpConfig(ReadEnable) 1
                    set Config(ReadEnable) 1
                    if {[winfo exists .cfg]} {
                        enablefetch .cfg.n
                    }
                }
                default { return -1 }
            }
        }
        speak {
            switch $args {
                now    {wxspeech 1}
                never  {
                    set tmpConfig(SpeechEnable) 0
                    set Config(SpeechEnable) 0
                    if {[winfo exists .cfg]} {
                        enablespeech .cfg.n.f5
                    }
                }
                always {
                    set tmpConfig(SpeechEnable) 1
                    set Config(SpeechEnable) 1
                    if {[winfo exists .cfg]} {
                        enablespeech .cfg.n.f5
                    }
                }
                serialonly {
                    set tmpConfig(SpeechEnable) 2
                    set Config(SpeechEnable) 2
                    if {[winfo exists .cfg]} {
                        enablespeech .cfg.n.f5
                    }
                }
                default { return -1 }
            }
        }
        hvwxvars {
            switch $args {
                disable {
                    set tmpConfig(HVWeatherEnable) 0
                    set Config(HVWeatherEnable) 0
                    if {[winfo exists .cfg]} {
                        enablehvwxvars .cfg.n.f6.f2
                    }
                }
                enable {
                    set tmpConfig(HVWeatherEnable) 1
                    set Config(HVWeatherEnable) 1
                    if {[winfo exists .cfg]} {
                        enablehvwxvars .cfg.n.f6.f2
                    }
                }
                default { return -1 }
            }
        }
        station {
            set pat [format {^weather: station "([a-z0-9]{4,5})"} ]
            if {[regexp $pat [string tolower $data] match id]} {
                WeatherSet current Station $id
                set nummatch [string length $match]
            } else {
                # Try again when there is more data available
                return 0
            }
        }
        current -
        forecast -
        both {
            set pat [format {^weather: %s (\w+)} $type]
            if {[regexp $pat [string tolower $data] match code]} {
                switch -nocase -- $code {
                    hvlatlong -
                    none -
                    nws -
                    metar -
                    OpenWeather {
                        WeatherSet $type $code
                        return [string length $match]
                    }
                    station {
                        set pat [format {^weather: %s station "([a-z0-9]{4,5})"} $type]
                    }
                    citycode {
                        set pat [format {^weather: %s citycode "([a-z0-9]+)"} $type]
                    }
                    zipcode {
                        set pat [format {^weather: %s zipcode "([0-9]{5})"} $type]
                    }
                    latlong {
                        set pat [format {^weather: %s latlong "([0-9+-.]+,[0-9+-.]+)"} $type]
                    }
                    default { return 0 }
                }
                if {[regexp $pat [string tolower $data] match id]} {
                    WeatherSet $type $code $id
                    set nummatch [string length $match]
                } else {
                    # Try again when there is more data available
                    return 0
                }
            } else {
                return 0
            }
        }
        default { return -1 }
    }
    return $nummatch
}

hvImport SpeechCommand
proc wxspeech {{sercmdtrig 0}} {
    global Wx Config Spcfg

    if {$Config(SpeechEnable)== 1 || \
       ($Config(SpeechEnable)== 2 && $sercmdtrig == 1)} {

        array unset w
        foreach n [dict keys $Spcfg] {
            set sci [dict get $Spcfg $n enable]
            if {$sci != 0} {
                set w($sci) $n
            }
        }
        foreach s [lsort -integer [array names w]] {
            switch -exact -- $w($s) {
                Location {
                    if {[isknown $Wx(Location)]} {
                        set ns $Wx(Location)
                        foreach {k} \
                          [lreverse [regexp -inline -all -indices {[0-9]{5,}} $ns]] {
                            foreach {i j} $k {}
                            set ns [string replace $ns $i $j \
                               " [split [string range $ns $i $j] {}] "]
                        }
                        SpeechCommand string \
                        "Location is $ns."
                    }
                }
                Station {
                    if {[isknown $Wx(Station)]} {
                        SpeechCommand string \
                        "Station is [split $Wx(Station) {}]."
                    }
                }
                Weather {
                    if {![isknown $Wx(Weather)]} {
                        if {[isknown $Wx(cloudstr)]} {
                            SpeechCommand string \
                            "Weather is $Wx(cloudstr)."
                        }
                    } else {
                        SpeechCommand string \
                        "Weather is [join $Wx(Weather) " "]."
                    }
                }
                Temperature {
                    if {[tempscale] eq "F"} {
                        if {[isknown $Wx(TempF)]} {
                            SpeechCommand string \
                            "Temperature is $Wx(TempF) degrees Fahrenheit."
                        }
                    } else {
                        if {[isknown $Wx(TempC)]} {
                            SpeechCommand string \
                            "Temperature is $Wx(TempC) degrees Celsius."
                        }
                    }
                }
                Dewpoint {
                    if {[tempscale] eq "F"} {
                        if {[isknown $Wx(DewpointF)]} {
                            SpeechCommand string \
                            "Dewpoint is $Wx(DewpointF) degrees Fahrenheit."
                        }
                    } else {
                        if {[isknown $Wx(DewpointC)]} {
                            SpeechCommand string \
                            "Dewpoint is $Wx(DewpointC) degrees Celsius."
                        }
                    }
                }
                Windchill {
                    if {[tempscale] eq "F"} {
                        if {[isknown $Wx(WindchillF)]} {
                            SpeechCommand string \
                            "Wehnd chill is $Wx(WindchillF) degrees Fahrenheit."
                        }
                    } else {
                        if {[isknown $Wx(WindchillC)]} {
                            SpeechCommand string \
                            "Wehnd chill is $Wx(WindchillC) degrees Celsius."
                        }
                    }
                }
                Heatindex {
                    if {[tempscale] eq "F"} {
                        if {[isknown $Wx(HeatIndexF)]} {
                            SpeechCommand string \
                            "Heat Index is, $Wx(HeatIndexF) degrees Fahrenheit."
                        }
                    } else {
                        if {[isknown $Wx(HeatIndexC)]} {
                            SpeechCommand string \
                            "Heat Index is $Wx(HeatIndexC) degrees Celsius."
                        }
                    }
                }
                Wind {
                    if {[isknown $Wx(Wind)]} {
                        SpeechCommand string \
                        "Wehnds [regsub -all {\(.*\)} \
                        [string map \
                        {MPH "miles per hour" \
                         KPH "kilometers per hour" \
                         KTS knots} $Wx(Wind)] ""]"
                    }
                }
                Humidity {
                    if {[isknown $Wx(Humidity)]} {
                        SpeechCommand string \
                        "Humidity is $Wx(Humidity) percent."
                    }
                }
                Pressure {
                    switch -exact -- $Config(PressureScale) {
                        "I" {
                            if {[isknown $Wx(PressureIn)]} {
                                set str "Pressure is $Wx(PressureIn) inches"
                            }
                        }
                        "M" {
                            if {[isknown $Wx(PressureMb)]} {
                                set str "Pressure is $Wx(PressureMb) millibars"
                            }
                        }
                        "C" {
                            if {[isknown $Wx(PressureMm)]} {
                                set str "Pressure is $Wx(PressureMm) millimeters"
                            }
                        }
                    }
                    SpeechCommand string $str
                }
                Visibility {
                    switch -exact -- $Config(SpeedScale) {
                        "K" {
                            if {[isknown $Wx(VisibilityKm)]} {
                                SpeechCommand string \
                                "Visibility is $Wx(VisibilityKm) meters."
                            }
                        }
                        "N" -
                        "M" -
                        "B" {
                            if {[isknown $Wx(VisibilityMi)]} {
                                SpeechCommand string \
                                "Visibility is $Wx(VisibilityMi) miles."
                            }
                        }
                    }
                }
            }
        }
    }
}

#! Procedure to get station web page
proc stationupdate {w} {
    global LinkA

    downloadstation $LinkA(station)
}

#! Download station data
proc downloadstation {link {loop 5}} {
    global FetchMsg

    .cfg.sta.f.b1 state disabled
    set FetchMsg "Getting Station Info from Web. Please Wait."
    debug "stationupdate: $link"
    .cfg.sta configure -cursor watch

    if {[catch {::http::geturl $link \
                -headers {Pragma no-cache Cache-Control no-cache} \
                -command [list httpCBstation $loop]} token]} {
        wxfail "Fetch" Station $token
    }
}

#! Callback function to process weather station data
proc httpCBstation {loop token} {
    global FetchMsg

    if {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] == 200 } {
        set data [::http::data $token]
        if {[catch {parseXMLstation data} rl]} {
            wxfail Parse STATION $rl $data
            .cfg.sta.f.b1 state !disabled
            set FetchMsg "Station Fetch Failed"
            .cfg.sta configure -cursor ""
        } else {
            debug [clock format [clock seconds] \
                -format "Stations Fetched [timedatefmt]"]
            getstatelist .cfg.sta.f
            getstationlist .cfg.sta.f
            stationsave
            .cfg.sta.f.b1 state !disabled
            set FetchMsg ""
            .cfg.sta configure -cursor ""
            set file [file join weather station_raw]
            if {[catch {hvConfigFile create $file.xml w} f]} {
                debug "create error: $f"
            } else {
                catch {
                    puts -nonewline $f $data
                    close $f
                }
            }
        }
        ::http::cleanup $token
    } elseif {[string equal -nocase [::http::status $token] "ok"] && \
            [::http::ncode $token] in {301 302 303}} {
        set nurls [getredirecturl $token]
        incr loop -1
        debug "Try:$loop;$nurls" blue
        ::http::cleanup $token
        if {$loop > 0} {
            if {[catch {downloadstation $nurls} token]} {
                wxfail "Fetch" STATION $token
                .cfg.sta.f.b1 state !disabled
                set FetchMsg "Station Fetch Failed"
                .cfg.sta configure -cursor ""
            }
        }
    } else {
        wxfail Read STATION "[::http::status $token]; [::http::ncode $token]"
        .cfg.sta.f.b1 state !disabled
        set FetchMsg "Station Fetch Failed"
        .cfg.sta configure -cursor ""
        ::http::cleanup $token
    }
}

#! Parse station XML data
proc parseXMLstation {d} {
    global StateStations StationNames Config
    upvar 1 $d xml

    set n [catch {dom parse -simple $xml doc}]
    if {$n} {
        return -code error "Bad reply from NOAA"
    }
    array unset StateStations
    set root [$doc documentElement]
    set snodes [$root selectNodes /wx_station_index/station]
    foreach s $snodes {
        set sn [$s selectNodes station_id]
        if {[$sn hasChildNodes]} {
            set station [[$sn firstChild] data]
        } else {
            continue
        }
        set sn [$s selectNodes state]
        if {[$sn hasChildNodes]} {
            set state [[$sn firstChild] data]
        } else {
            continue
        }
        set sn [$s selectNodes station_name]
        if {[$sn hasChildNodes]} {
            set name [string map {&amp; &} [[$sn firstChild] data]]
        } else {
            set name ""
        }
        if {$Config(ShortStationList)} {
            if {[regexp -nocase [format {%s[0-9]+} $state] $station]} {
                continue
            }
            if {[string length $station] != 4 && \
                ![regexp -nocase {air} $name]} {
                continue
            }
        }
        set StationNames($station) $name
        set StationNames($station,state) $state
        lappend StateStations($state) $station

        set StationNames($station,lat) ""
        set sn [$s selectNodes latitude]
        if {[$sn hasChildNodes]} {
            set StationNames($station,lat) [[$sn firstChild] data]
        }
        set StationNames($station,lon) ""
        set sn [$s selectNodes longitude]
        if {[$sn hasChildNodes]} {
            set StationNames($station,lon) [[$sn firstChild] data]
        }
        set sn [$s selectNodes hide]
        if {$sn ne "" && [$sn hasChildNodes]} {
            set StationNames($station,hide) [[$sn firstChild] data]
        } else {
            set StationNames($station,hide) unhide
        }
    }
    $doc delete
}

#! Save station info to cache file.
proc stationsave {} {

    set file [file join weather station_cache]
    if {[catch {hvConfigFile create $file.$$$ w} f]} {
        debug "create error: $f"
        return
    }

    if {[catch {stationwrite $f} err]} {
        catch {close $f}
        hvConfigFile delete $file.$$$
        debug "write error: $err"
        return
    }
    catch {close $f}
    hvConfigFile rename $file.$$$ $file.xml
    debug "Write Success!"
}

#! Write station info to cache file.
proc stationwrite { f } {
    global StateStations StationNames

    puts $f [format {<?xml version="1.0" encoding="UTF-8"?>}]
    puts $f [format {<wx_station_index>}]
    foreach st [lsort -dictionary [array names StateStations]] {
        foreach sn [lsort -dictionary $StateStations($st)] {
            if {$StationNames($sn,hide) eq "delete"} {
               array unset StationNames $sn
               array unset StationNames $sn,*
               set idx [lsearch -exact $StateStations($st) $sn]
               set StateStations($st) [lreplace $StateStations($st) $idx $idx]
               continue
            }
            puts $f [format {<station>}]
            puts -nonewline $f [format { <%1$s>%2$s</%1$s>} "station_id" $sn]
            puts $f [format {<%1$s>%2$s</%1$s>} "state" $st]
            puts $f [format { <%1$s>%2$s</%1$s>} "station_name" [string map {& &amp;} $StationNames($sn)]]
            puts -nonewline $f [format { <%1$s>%2$s</%1$s>} "latitude" $StationNames($sn,lat)]
            puts $f [format {<%1$s>%2$s</%1$s>} "longitude" $StationNames($sn,lon)]
            puts $f [format { <%1$s>%2$s</%1$s>} "hide" $StationNames($sn,hide)]
            puts $f [format {</station>}]
        }
    }
    puts $f {</wx_station_index>}
}

#! Get station info from cache file, it it exists.
proc stationrefresh { } {
    global StationNames

    if {[info exists StationNames]} {
        return 1
    }
    if {[catch {hvConfigFile open [file join weather station_cache.xml]} f]} {
        debug "Can't open station file, $f" red
        return 0
    }

    set data [read $f]
    if {[catch {parseXMLstation data} rl]} {
        wxfail Parse STATION $rl $data
        close $f
        return 0
    }
    close $f
    return 1
}

#! Find closest NWS station for given latitude and longitude
#     Look within a "square" approx 400 miles per side
proc findstation {lat lon} {
    global StationNames Config

    set length 4
    set dist 15000.0
    set station ""
    if {$Config(SpeedScale) eq "K"} {
        set r 6371
    } else {
        set r 3959
    }
    foreach n [array names StationNames -regexp {^[[:alnum:]]+$}] {
        if {[string length $n] != $length} continue
        if {$StationNames($n,hide) eq "hide"} continue
        set y [expr {abs ($StationNames($n,lat) - $lat)}]
        # Only consider stations within ~207 miles (207 mi / 69 mi/degrees = 3 degrees)
        if {$y <= 3} {
            set x [expr {abs ($StationNames($n,lon) - $lon)}]
            # Only consider stations within ~200 miles (approx miles/degree long using lat)
            if {$x <= 200/(90.5 - abs($lat))} {
                set tdist [expr {acos(sin($StationNames($n,lat)/57.296)*sin($lat/57.296)+ \
                    cos($StationNames($n,lat)/57.296)*cos($lat/57.296)* \
                    cos(($StationNames($n,lon) - $lon)/57.296))*$r} ]
#debug "fs: $n: $StationNames($n,lat),$StationNames($n,lon);[expr {$StationNames($n,lat) - $lat}],[expr {$StationNames($n,lon) - $lon}], $tdist, $dist" red
                if {$tdist < $dist} {
                    set dist $tdist
                    set station $n
                }
            }
        }
    }
    if {$station ne ""} {
#        debug "station found: $station:$dist,$StationNames($station),$StationNames($station,lat),$StationNames($station,lon),$lat,$lon" purple
    }
    return $station
}

#! Get location info for given latitude and longitude
proc geonames {lat lng} {
    global geonames

    set loc "$lat,$lng"
#    debug "geonames: $loc" darkgreen
#    if {[info exists geonames]} {debug "geonames: $geonames" darkgreen}

    if {[info exists geonames] && [dict exists $geonames $loc]} {
        return [lindex [dict get $geonames $loc cities] 0]
    }
    set proxy [hvVariable WizardProxy]
    set re {(?:http://)?(?:(?:([^:@/]+):)?([^:@/]+)@)?([^:@/]+)(?::([^:@/]*))?/?}
    if {[regexp $re $proxy -> user pass host port]} {
        ::http::config -proxyhost $host -proxyport $port
    }
    set url http://api.geonames.org/findNearbyPlaceNameJSON
    set query [format lat=%s&lng=%s&maxRows=%d&radius=%d&username=hvxl_geon $lat $lng 10 10]
    if {[catch {::http::geturl $url?$query -timeout 10000} tok]} {
        debug $tok
        return
    }
    set status [::http::status $tok]
    set data [::http::data $tok]
    ::http::cleanup $tok
    if {$status ne "ok"} {
        debug "$status\n$data"
        return
    }
    if {[catch {::json::json2dict $data} json]} {
        debug $json
        return
    }
    if {![dict exists $json geonames]} {
        debug $json
        return
    }
    set cities {}; set x 0
    foreach n [dict get $json geonames] {
        if {[dict get $n fcode] != "PPL"} continue
        if {[dict get $n population] > 0} {
            set cities [linsert $cities $x $n]
            incr x
        } else {
            lappend cities $n
        }
    }
    dict set geonames $loc cities $cities
    return [lindex $cities 0]
}

#! Get location info for given latitude and longitude
proc geozip {zipcode} {
    global geonames

    debug "geozip: $zipcode" darkgreen
#    if {[info exists geonames]} {debug "geozip: $geonames" darkgreen}

    if {[info exists geonames] && [dict exists $geonames $zipcode]} {
#        debug [dict get $geonames $zipcode latlong] red
        return [dict get $geonames $zipcode latlong]
    }
    set proxy [hvVariable WizardProxy]
    set re {(?:http://)?(?:(?:([^:@/]+):)?([^:@/]+)@)?([^:@/]+)(?::([^:@/]*))?/?}
    if {[regexp $re $proxy -> user pass host port]} {
        ::http::config -proxyhost $host -proxyport $port
    }
    set url http://api.geonames.org/postalCodeSearchJSON
    set query [format postalcode=%s&maxRows=%d&username=hvxl_geon&country=US $zipcode 10]
#    debug "geozip:$url?$query" blue
    if {[catch {::http::geturl $url?$query -timeout 10000} tok]} {
        debug $tok
        return
    }
    set status [::http::status $tok]
    set data [::http::data $tok]
    ::http::cleanup $tok
#    debug "geozip:$data" red
    if {$status ne "ok"} {
        debug "$status\n$data"
        return
    }
    if {[catch {::json::json2dict $data} json]} {
        debug $json
        return
    }
    if {![dict exists $json postalCodes]} {
        debug $json
        return
    }
    
    set zips [dict get $json postalCodes]
    set city [lindex $zips 0]
    if {[dict exists $city lat] && [dict exists $city lng]} {
        set lat [dict get $city lat]
        set lon [dict get $city lng]
        dict set geonames $zipcode latlong "$lat $lon"
    } else {
        set lat [hvVariable Latitude]
        set lon [hvVariable Longitude]
    }
#    debug "lat:$lat,lon:$lon" red
    return "$lat $lon"
}

#! Write weather info to HomeVision controller
proc sethvwxvars { tag val } {
    global Config IconNames Wx

#debug "sethvwxvars:$tag,$val; " red
    if {$Config(HVWeatherEnable) != 1} {return}
    set cmd ""
    switch -- $tag {
        temp_f {
            if {[tempscale] eq "F"} {
                if {[string is integer -strict $val]} {
                    set cmd [format ",^0003%02X" [expr {$val + 100}]]
                } else {
                    set cmd [format ",^0003%02X" 255]
                }
            } else {
                set cmd ""
            }
        }
        temp_c {
            if {[tempscale] eq "C"} {
                if {[string is integer -strict $val]} {
                    set cmd [format ",^0003%02X" [expr {$val + 100}]]
                } else {
                    set cmd [format ",^0003%02X" 255]
                }
            } else {
                set cmd ""
            }
        }
        relative_humidity {
            if {[string is integer -strict $val]} {
                set cmd [format ",^0009%02X" [expr {$val}]]
            } else {
                set cmd [format ",^0009%02X" 255]
            }
        }
        pressure_in {
            if {$Config(PressureScale) eq "I"} {
                if {[regexp {^([0-9]+)\.([0-9]+)$} $val -> u h]} {
                    set cmd [format ",^000C%02X" [scan $u "%d"]]
                    lappend cmd [format ",^000D%02X" [scan $h "%d"]]
                } else {
                    set cmd [format ",^000C%02X" 255]
                    lappend cmd [format ",^000D%02X" 255]
                }
            } else {
                set cmd ""
            }
        }
        pressure_mb {
            if {$Config(PressureScale) eq "M"} {
                set val [format "%.2f" [expr {$val / 100.0}]]
                if {[regexp {^([0-9]+)\.([0-9]+)$} $val -> u h]} {
                    set cmd [format ",^000C%02X" [scan $u "%d"]]
                    lappend cmd [format ",^000D%02X" [scan $h "%d"]]
                } else {
                    set cmd [format ",^000C%02X" 255]
                    lappend cmd [format ",^000D%02X" 255]
                }
            } else {
                set cmd ""
            }
        }
        pressure_mm {
            if {$Config(PressureScale) eq "C"} {
                set val [format "%.2f" [expr {$val / 10.0}]]
                if {[regexp {^([0-9]+)\.([0-9]+)$} $val -> u h]} {
                    set cmd [format ",^000C%02X" [scan $u "%d"]]
                    lappend cmd [format ",^000D%02X" [scan $h "%d"]]
                } else {
                    set cmd [format ",^000C%02X" 255]
                    lappend cmd [format ",^000D%02X" 255]
                }
            } else {
                set cmd ""
            }
        }
        pressure_rate {
            if {[string is double -strict $val]} {
                if {$val > 1} {
                    set cmd [format ",^000E%02X" 2]
                } elseif {$val < -1} {
                    set cmd [format ",^000E%02X" 0]
                } else {
                    set cmd [format ",^000E%02X" 1]
                }
            } else {
                    set cmd [format ",^000E%02X" 255]
            }
        }
        wind_degrees {
            if {[string is integer -strict $val] && $val <= 360} {
                set cmd [format ",^000F%02X" [expr {$val / 100}]]
                lappend cmd [format ",^0010%02x" [expr {$val % 100}]]
            } else {
                set cmd [format ",^000F%02X" 255]
                lappend cmd [format ",^0010%02X" 255]
            }
        }
        wind_mph {
            if {$Config(SpeedScale) eq "M"} {
                if {[regexp {^[0-9.]+$} $val]} {
                    set cmd [format ",^0011%02X" [expr {round($val)}]]
                } else {
                    set cmd [format ",^0011%02X" 255]
                }
            }
        }
        wind_kph {
            if {$Config(SpeedScale) eq "K"} {
                if {[regexp {^[0-9.]+$} $val]} {
                    set cmd [format ",^0011%02X" [expr {round($val)}]]
                } else {
                    set cmd [format ",^0011%02X" 255]
                }
            }
        }
        wind_kt {
            if {$Config(SpeedScale) eq "N"} {
                if {[regexp {^[0-9.]+$} $val]} {
                    set cmd [format ",^0011%02X" [expr {round($val)}]]
                } else {
                    set cmd [format ",^0011%02X" 255]
                }
            }
        }
        wind_bea {
            if {$Config(SpeedScale) eq "B"} {
                if {[regexp {^[0-9.]+$} $val]} {
                    set cmd [format ",^0011%02X" [expr {round($val)}]]
                } else {
                    set cmd [format ",^0011%02X" 255]
                }
            }
        }
        icon_url_name {
            set cnt [hvObjectCount var]
            if {$Config(HVWeatherVar) < $cnt} {
                if {$Config(WeatherType) eq "W"} {
                    set val $Wx(WeatherId)
                } else {
                set val [file rootname $val]
                if {[string equal -length 3 $val "wx_"]} {
                    set val [string range $val 3 end]
                }
                if {$val ne "ra1" && ![string equal -length 4 $val "cond"]} {
                    set val [string trimright $val "0123456789"]
                }
                }
                if {[info exists IconNames($val)]} {
                    set cmd [format ",?%02X00%02X" $Config(HVWeatherVar) $IconNames($val)]
                } else {
                    set cmd [format ",?%02X00%02X" $Config(HVWeatherVar) 0]
                }
            } else {
                set cmd ""
            }
        }
        observation_time {
            set time [clock scan  $val \
                     -format "Last Updated on [timedatefmt]"]
            scan [clock format $time \
                     -format {%N:%d:%k:%M}] "%d:%d:%d:%d" month day hour minute

            set cnt [hvObjectCount var]
            if {$Config(HVObsTimeVar) < $cnt} {
                set wvar $Config(HVObsTimeVar)
                set cmd [format ",?%02X00%02X" $wvar $minute]
                incr wvar
                lappend cmd [format ",?%02X00%02X" $wvar $hour]
            }
            if {$Config(HVObsDateVar) < $cnt} {
                set wvar $Config(HVObsDateVar)
                lappend cmd [format ",?%02X00%02X" $wvar $day]
                incr wvar
                lappend cmd [format ",?%02X00%02X" $wvar $month]
            }
        }
        station_id {
            set cnt [hvObjectCount var]
            if {$Config(HVStationIDVar) < $cnt} {
                set wvar $Config(HVStationIDVar)
                for {set i 0} {$i < 5} {incr i;incr wvar} {
                    set c [string index $val $i]
                    if {$c eq ""} {set c " "}
                    binary scan $c c c
                    lappend cmd [format ",?%02X00%02X" $wvar $c]
                }
            }
         }
        pop {
            set cnt [hvObjectCount var]
            if {$Config(HVPoPVar) < $cnt} {
                lappend cmd [format ",?%02X00%02X" $Config(HVPoPVar) $val]
            }
         }
        clouds {
            set cnt [hvObjectCount var]
            if {$Config(HVCloudVar) < $cnt} {
                lappend cmd [format ",?%02X00%02X" $Config(HVCloudVar) $val]
            }
         }
        default {
            return
        }
    }
    foreach c $cmd {
        debug $c blue
        catch {hvSendCommand $c}
    }
}

proc calc_windchill { tempf windspeed wcnm wcfnm wccnm } {
    global Config
    upvar 1 $wcnm windchill
    upvar 1 $wcfnm windchillf
    upvar 1 $wccnm windchillc
    if {![isknown $windchillf] && ![isknown $windchillc]} {
        if { $tempf > 50 || $tempf < -58 || $windspeed < 3 || \
            ![isknown $tempf] || ![isknown $windspeed]} {
            set windchill "NA"
            set windchillf "NA"
            set windchillc "NA"
            return
        }

    #   WC = 35.74 + 0.6215*T - 35.75*V^{0.16} + 0.4275*T*V^{0.16}

        set vp [expr {pow($windspeed,0.16)}]
        set windchillf \
            [expr {round(35.74 + (0.6215*$tempf) - (35.75*$vp) \
            + (0.4275*$tempf*$vp))}]
        set windchillc [expr {round(($windchillf - 32) / 1.8)}]
    }
    if {![isknown $windchillc]} {
        set windchillc [expr {round(($windchillf - 32) / 1.8)}]
    }
    if {![isknown $windchillf]} {
        set windchillf [expr {round((1.8*$windchillc) + 32)}]
    }

    if {[tempscale] eq "F"} {
        set windchill [format "%.0f F (%.0f C)" $windchillf $windchillc]
    } else {
        set windchill [format "%.0f C (%.0f F)" $windchillc $windchillf]
    }
}

proc calc_heatindex { tempf humidity hinm hifnm hicnm } {
    global Config

    upvar 1 $hinm heatindex
    upvar 1 $hifnm heatindexf
    upvar 1 $hicnm heatindexc

    if {![isknown $heatindexf] &&![isknown $heatindexc]} {
        if { $tempf < 80 || $humidity < 40 || \
            ![isknown $tempf] || ![isknown $humidity]} {
            set heatindex "NA"
            set heatindexf "NA"
            set heatindexc "NA"
            return
        }

    #   HI = -42.379 + 2.04901523*T + 10.14333127*RH - 0.22475541*T*RH
    #        - 6.83783x10^-3*T^2 - 5.481717x10^-2*RH^2 + 1.22874x10^-3*T^2*RH
    #        + 8.5282x10^-4*T*RH^2 - 1.99x10^-6*T^2*RH^2

        set t2 [expr {$tempf*$tempf}]
        set h2 [expr {$humidity*$humidity}]
        set heatindexf \
            [expr {round(-42.379 + (2.04901523*$tempf) + (10.14333127*$humidity) \
            - (0.22475541*$tempf*$humidity) - (0.00683783*$t2) \
            - (0.05481717*$h2) + (0.00122874*$t2*$humidity) \
            + (0.00085282*$tempf*$h2) - (0.00000199*$t2*$h2))}]
        set heatindexc [expr {round(($heatindexf - 32) / 1.8)}]
    }
    if {![isknown $heatindexc]} {
        set heatindexc [expr {round(($heatindexf - 32) / 1.8)}]
    }
    if {![isknown $heatindexf]} {
        set heatindexf [expr {round((1.8*$heatindexc) + 32)}]
    }
    if {[tempscale] eq "F"} {
        set heatindex [format "%.0f F (%.0f C)" $heatindexf $heatindexc]
    } else {
        set heatindex [format "%.0f C (%.0f F)" $heatindexc $heatindexf]
    }
}

proc wxpostprocess {} {
    global Wx Config

    if {[isknown $Wx(TempF)]} {
        if {![isknown $Wx(TempC)]} {
            set Wx(TempC) [expr {round(0.556 * ($Wx(TempF) - 32))}]
        } else {
            set Wx(TempC) [expr {round($Wx(TempC))}]
        }
        set Wx(TempF) [expr {round($Wx(TempF))}]
    } else {
        if {[isknown $Wx(TempC)]} {
            set Wx(TempF) [expr {round((1.8 * $Wx(TempC)) + 32)}]
            set Wx(TempC) [expr {round($Wx(TempC))}]
        }
    }
    if {[isknown $Wx(TempF)] && [isknown $Wx(TempC)]} {
        if {[tempscale] eq "F"} {
            set Wx(Temp) [format "%.0f F (%.0f C)" $Wx(TempF) $Wx(TempC)]
        } else {
            set Wx(Temp) [format "%.0f C (%.0f F)" $Wx(TempC) $Wx(TempF)]
        }
    } else {
        set Wx(Temp) "NA"
    }

    if {[string is double -strict $Wx(FeelsLike)]} {
        set Wx(FeelsLike) [expr {round($Wx(FeelsLike))}]
    }
    if {[isknown $Wx(DewpointF)]} {
        if {![isknown $Wx(DewpointC)]} {
            set Wx(DewpointC) [expr {round(0.556 * ($Wx(DewpointF) - 32))}]
        } else {
            set Wx(DewpointC) [expr {round($Wx(DewpointC))}]
        }
        set Wx(DewpointF) [expr {round($Wx(DewpointF))}]
    } else {
        if {[isknown $Wx(DewpointC)]} {
            set Wx(DewpointF) [expr {round((1.8 * $Wx(DewpointC)) + 32)}]
            set Wx(DewpointC) [expr {round($Wx(DewpointC))}]
        }
    }
    if {[isknown $Wx(DewpointF)] && [isknown $Wx(DewpointC)]} {
        if {[tempscale] eq "F"} {
            set Wx(Dewpoint) [format "%.0f F (%.0f C)" $Wx(DewpointF) $Wx(DewpointC)]
        } else {
            set Wx(Dewpoint) [format "%.0f C (%.0f F)" $Wx(DewpointC) $Wx(DewpointF)]
        }
    } else {
        set Wx(Dewpoint) "NA"
    }
    # calculate the relative humidity
    if {![isknown $Wx(Humidity)]} {
        if {[isknown $Wx(DewpointC)]  && [isknown $Wx(TempC)]} {
            set sat [expr {6.11 * pow(10, 7.5 * $Wx(TempC)/ (237.7 + $Wx(TempC)))}]
            set surf [expr {6.11 * pow(10, 7.5 * $Wx(DewpointC) / (237.7 + $Wx(DewpointC)))}]
            set Wx(Humidity) [expr {round($surf / $sat * 100.00)}]
        }
    }

    calc_windchill $Wx(TempF) $Wx(WindMPH) Wx(Windchill) Wx(WindchillF) Wx(WindchillC)
    calc_heatindex $Wx(TempF) $Wx(Humidity) Wx(HeatIndex) Wx(HeatIndexF) Wx(HeatIndexC)

    if {[isknown $Wx(PressureIn)]} {
        set Wx(PressureIn) [format "%.2f" $Wx(PressureIn)]
        if {![isknown $Wx(PressureMb)]} {
            set Wx(PressureMb) [format "%.0f" [expr {$Wx(PressureIn)*33.864}]]
        }
    } else {
        if {[isknown $Wx(PressureMb)]} {
            set Wx(PressureIn) [format "%.2f" [expr {$Wx(PressureMb)/33.864}]]
            set Wx(PressureMb) [format "%.0f" $Wx(PressureMb)]
        }
    }
    if {[isknown $Wx(PressureIn)] && [isknown $Wx(PressureMb)]} {
        set Wx(PressureMm) [format "%.1f" [expr {$Wx(PressureIn) * 25.4}]]
        switch -exact -- $Config(PressureScale) {
            "I" {
                set Wx(Pressure) [format {%.2f"} $Wx(PressureIn)]
            }
            "M" {
                set Wx(Pressure) [format "%.0f mb" $Wx(PressureMb)]
            }
            "C" {
                set Wx(Pressure) [format "%.1f mm" $Wx(PressureMm)]
            }
        }
    }
# get rid of quote issue with NotePad2 "

    if {![isknown $Wx(VisibilityMi)] && [isknown $Wx(VisibilityKm)]} {
        if {$Wx(VisibilityKm) == 0000} {
            set Wx(VisibilityKm) 50
            set Wx(VisibilityMi) 0
        } elseif {$Wx(VisibilityKm) == 9999 || \
                  $Wx(VisibilityKm) == 10000} {
            set Wx(VisibilityKm) 10000
            set Wx(VisibilityMi) 10
        } else {
            set Wx(VisibilityMi) \
                [format "%.2f" [expr {$Wx(VisibilityKm) * 0.0006213}]]
        }
    }
    if {[isknown $Wx(VisibilityMi)] && ![isknown $Wx(VisibilityKm)]} {
        set Wx(VisibilityKm) \
            [format "%.0f" [expr {round($Wx(VisibilityMi) * 16.09) * 100}]]
    }
    if {[isknown $Wx(VisibilityMi)]} {
        if {$Wx(VisibilityMi) < 3 && fmod($Wx(VisibilityMi),1)} {
            set Wx(VisibilityMi) [format "%.2f" $Wx(VisibilityMi)]
        } else {
            set Wx(VisibilityMi) [format "%.0f" $Wx(VisibilityMi)]
        }
    }
    if {![isknown $Wx(WeatherIcon)] && [isknown $Wx(cloudstype)]} {
        set Wx(WeatherIcon) "[string tolower [lindex $Wx(cloudstype) end]$::Iconext]"
    }
    if {![isknown $Wx(WeatherIcon)]} {
        if {$Config(WeatherType) eq "W"} {
            set Wx(WeatherIcon) 01d.png
        } else {
            set Wx(WeatherIcon) na$::Iconext
        }
    }

    if {![isknown $Wx(Weather)]} {
        if {[isknown $Wx(cloudstr)]} {
            set Wx(Weather) $Wx(cloudstr)
        }
    } else {
        set Wx(Weather) [join $Wx(Weather) " "]
    }
}

proc varset {w cfg} {
    upvar #0 $w WFx $cfg WFxcfg

    foreach v [lsort [dict keys $WFxcfg]] {
        debug "$v = $WFx($v)" blue
        if {[dict get $WFxcfg $v ctl_enable]} {
            if {$v in {ZipCode FCZip}} {
                ControlSetVar $v "$WFx($v)     ZC"
            } else {
                ControlSetVar $v $WFx($v)
            }
        }
    }
}

proc isknown {wd} {
    if {$wd in {<unknown> NA ""}} {
        return 0
    }
    return 1
}

proc timedatefmt { } {
    global Config

    if {$Config(TimeFormat) eq "U"} {
        return "%b %e %Y, %l:%M %p %z"
    } elseif {$Config(TimeFormat) eq "E"} {
        return "%e %b %Y, %H:%M %z"
    } else {
        return "[hvVariable DateFormat] [hvVariable TimeFormat]"
    }
}

proc timefmt {} {
    global Config

    if {$Config(TimeFormat) eq "U"} {
        return "%l:%M %p"
    } elseif {$Config(TimeFormat) eq "E"} {
        return "%H:%M %z"
    } else {
        return "[hvVariable TimeFormat]"
    }
}

proc tempscale {} {
    global Config

    if {$Config(TempScale) eq "H"} {
        return [expr {[hvVariable TempScale] == -1 ? "C" : "F"}]
    } else {
        return $Config(TempScale)
    }
}

#**************
# Portions of the following source were obtained from:
# http://wiki.tcl.tk/19635
# tclmetar 0.1 by: Jos Decoster http://jos.decoster.googlepages.com/
#
# with get_winddirstr modified with similar proc from
# http://wiki.tcl.tk/3568
# TclWeather 1.11 by Jason Tang (tang@jtang.org)
#
# Extensively modified by Ron Boston
#

proc get_winddirstr { angle } {

    if {$angle eq ""} {
        return ""
    } elseif {$angle eq "VRB"} {
        return "Variable winds"
    } elseif {$angle < 0} {
        return "Variable winds"
    } elseif {$angle <= 11 || $angle >= 349} {
        return "From the north"
    } elseif {$angle <= 33} {
        return "From the north-northeast"
    } elseif {$angle <= 56} {
        return "From the northeast"
    } elseif {$angle <= 78} {
        return "From the east-northeast"
    } elseif {$angle <= 101} {
        return "From the east"
    } elseif {$angle <= 123} {
        return "From the east-southeast"
    } elseif {$angle <= 146} {
        return "From the southeast"
    } elseif {$angle <= 168} {
        return "From the south-southeast"
    } elseif {$angle <= 191} {
        return "From the south"
    } elseif {$angle <= 213} {
        return "From the south-southwest"
    } elseif {$angle <= 236} {
        return "From the southwest"
    } elseif {$angle <= 258} {
        return "From the west-southwest"
    } elseif {$angle <= 281} {
        return "From the west"
    } elseif {$angle <= 303} {
        return "From the west-northwest"
    } elseif {$angle <= 326} {
        return "From the northwest"
    } elseif {$angle <= 348} {
        return "From the north-northwest"
    }
    return $angle
}

proc mph_to_beaufort {windb bscalenm bstringnm} {
    upvar 1 $bscalenm force
    upvar 1 $bstringnm beaufort

    if {$windb < 1}  {
         set beaufort "Calm"
         set force 0
    } elseif {$windb < 3}  {
         set beaufort "Light air"
         set force  1
    } elseif {$windb < 7}  {
         set beaufort "Light breeze"
         set force 2
    } elseif {$windb < 12}  {
         set beaufort "Gentle breeze"
         set force 3
    } elseif {$windb < 18}  {
         set beaufort "Moderate breeze"
         set force 4
    } elseif {$windb < 24}  {
         set beaufort "Fresh breeze"
         set force 5
    } elseif {$windb < 31}  {
         set beaufort "Strong breeze"
         set force 6
    } elseif {$windb < 38}  {
         set beaufort "Moderate or Near Gale"
         set force 7
    } elseif {$windb < 46}  {
         set beaufort "Gale or Fresh Gale"
         set force 8
    } elseif {$windb < 54}  {
         set beaufort "Strong Gale"
         set force 9
    } elseif {$windb < 63}  {
         set beaufort "Whole Gale or Storm"
         set force 10
    } elseif {$windb <= 72}  {
         set beaufort "Violent Storm"
         set force 11
    } elseif {$windb > 72}  {
         set beaufort "Hurricane"
         set force 12
    } else  {
          set beaufort "unknown"
          set force 0
    }
}

proc parse_wind { f wd ws wg wu d wfx} {
    global Config
        upvar #0 $wfx WFx

    set p ""
    if {$wfx eq "Fx"} {
        set p "Fc"
    }

#   debug "PW:$wd:$ws:$wg:$wu:$p:$d:$wfx;" blue
    set calm 0
    if {$wd ne "///"} {
        if {$wd eq "VRB"} {
            set WFx(${p}WindDegrees${d}) 0
            set WFx(${p}WindDir${d}) [get_winddirstr $wd]
        } else {
            set WFx(${p}WindDegrees${d}) [scan $wd "%d"]
            set WFx(${p}WindDir${d}) [get_winddirstr $WFx(${p}WindDegrees${d})]
            if {$WFx(${p}WindDegrees${d}) == 0} {incr calm}
        }
        set wxstr [format "%s" $WFx(${p}WindDir${d})]
    } else {
        set WFx(${p}WindDir${d}) "NA"
        set WFx(${p}WindDegrees${d}) "NA"
        set wxstr ""
    }
    if {$ws ne "//"} {
        set WFx(${p}WindKPH${d}) [scan $ws "%f"]
        if {$WFx(${p}WindKPH${d}) == 0} {incr calm}
        switch -exact -- $wu {
        "KT" {
            set WFx(${p}WindMPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 1.151)}]
            set WFx(${p}WindKTS${d}) [expr {round($WFx(${p}WindKPH${d}))}]
            set WFx(${p}WindKPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 1.853)}]
        }
        "MPH" {
            set WFx(${p}WindMPH${d}) [expr {round($WFx(${p}WindKPH${d}))}]
            set WFx(${p}WindKTS${d}) [expr {round($WFx(${p}WindKPH${d}) * 0.869)}]
            set WFx(${p}WindKPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 1.609)}]
        }
        "MPS" {
            set WFx(${p}WindMPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 2.237)}]
            set WFx(${p}WindKTS${d}) [expr {round($WFx(${p}WindKPH${d}) * 1.944)}]
            set WFx(${p}WindKPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 3.6)}]
        }
        "KMH" {
            set WFx(${p}WindMPH${d}) [expr {round($WFx(${p}WindKPH${d}) * 0.6213)}]
            set WFx(${p}WindKTS${d}) [expr {round($WFx(${p}WindKPH${d}) * 0.54)}]
            set WFx(${p}WindKPH${d}) [expr {round($WFx(${p}WindKPH${d}))}]
        }
        }
        mph_to_beaufort $WFx(${p}WindMPH${d}) WFx(${p}WindBft${d}) WFx(${p}beaufortstr${d})

        if {$wxstr != ""} {
            set lstr " at "
            set bstr ", "
        } else {
            set lstr ""
            set bstr ""
        }
        switch -exact -- $Config(SpeedScale) {
        "M" {
            set wxstr [format "%s%s%d MPH" $wxstr $lstr $WFx(${p}WindMPH${d})]
        }
        "K" {
            set wxstr [format "%s%s%d KPH" $wxstr $lstr $WFx(${p}WindKPH${d})]
        }
        "N" {
            set wxstr [format "%s%s%d KTS" $wxstr $lstr $WFx(${p}WindKTS${d})]
        }
        "B" {
            set wxstr [format "%s%s%s (%d)" $wxstr $bstr $WFx(${p}beaufortstr${d}) $WFx(${p}WindBft${d})]
        }
        }
    } else {
        set WFx(${p}WindMPH${d}) "NA"
        set WFx(${p}WindKPH${d}) "NA"
        set WFx(${p}WindKTS${d}) "NA"
        set WFx(${p}WindBft${d}) "NA"
    }
    if {![string length $wg] == 0} {
        set WFx(${p}WindGustKPH${d}) [scan [string range $wg 1 end] "%d"]
        if {$WFx(${p}WindGustKPH${d}) == 0} {incr calm}
        switch -exact -- $wu {
        "KT" {
            set WFx(${p}WindGustMPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 1.151)}]
            set WFx(${p}WindGustKTS${d}) [expr {round($WFx(${p}WindGustKPH${d}))}]
            set WFx(${p}WindGustKPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 1.853)}]
        }
        "MPH" {
            set WFx(${p}WindGustMPH${d}) [expr {round($WFx(${p}WindGustKPH${d}))}]
            set WFx(${p}WindGustKTS${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 0.869)}]
            set WFx(${p}WindGustKPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 1.609)}]
        }
        "MPS" {
            set WFx(${p}WindGustMPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 2.237)}]
            set WFx(${p}WindGustKTS${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 1.944)}]
            set WFx(${p}WindGustKPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 3.6)}]
        }
        "KMH" {
            set WFx(${p}WindGustMPH${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 0.6213)}]
            set WFx(${p}WindGustKTS${d}) [expr {round($WFx(${p}WindGustKPH${d}) * 0.54)}]
            set WFx(${p}WindGustKPH${d}) [expr {round($WFx(${p}WindGustKPH${d}))}]
        }
        }
        if {$wxstr != ""} {
            set lstr ", gusting at "
        } else {
            set lstr "Gusting at "
        }
        switch -exact -- $Config(SpeedScale) {
        "M" {
            set wxstr [format "%s%s%d MPH" $wxstr $lstr $WFx(${p}WindGustMPH${d})]
        }
        "K" {
            set wxstr [format "%s%s%d KPH" $wxstr $lstr $WFx(${p}WindGustKPH${d})]
        }
        "N" {
            set wxstr [format "%s%s%d KTS" $wxstr $lstr $WFx(${p}WindGustKTS${d})]
        }
        }

    } else {
        set WFx(${p}WindGustMPH${d}) "NA"
        set WFx(${p}WindGustKPH${d}) "NA"
        set WFx(${p}WindGustKTS${d}) "NA"
        incr calm
    }
    if {$calm == 3} {
        set WFx(${p}Wind${d}) "Calm"
    } elseif {$wxstr != ""} {
        set WFx(${p}Wind${d}) $wxstr
    } else {
        set WFx(${p}Wind${d}) NA
    }
#    debug "[array get WFx {Wind*}]" blue
}

proc parse_wind_variability { wvf wvfnm wvfstrnm wvt wvtnm wvtstrnm } {
    upvar 1 $wvfnm windvarfrom
    upvar 1 $wvfstrnm windvarfromstr
    upvar 1 $wvtnm windvarto
    upvar 1 $wvtstrnm windvartostr

    set windvarfrom [scan $wvf "%d"]
    set windvarfromstr [get_winddirstr $windvarfrom]
    set windvarto   [scan $wvt "%d"]
    set windvartostr   [get_winddirstr $windvarto]
}

proc parse_temperature { f tempnm } {
    upvar 1 $tempnm temp

    if {[string match "//" $f] || [string length $f] == 0 } {
        return
    }
    if {[string match "M*" $f]} {
        set temp [expr {0 - [scan [string range $f 1 end] "%d"]}]
    } else {
        set temp [scan $f "%d"]
    }
}

proc parse_clouds { ct ctypenm ch chnm cbtcu tcnm cnnm cstrnm} {
    upvar 1 $ctypenm cloudstype
    upvar 1 $chnm    cloudsheight
    upvar 1 $tcnm    toweringcumulus
    upvar 1 $cnnm    cumulonimbus
    upvar 1 $cstrnm  cloudstr
    foreach {cloud_code cloud_desc} { \
        "SKC" "Clear Skies"           "CLR" "Clear Skies" \
        "NSC" "No Significant Clouds" "NCD" "No Clouds Detected" \
        \
        "FEW" "Mostly Clear Skies"    "SCT" "Partly Cloudy" \
        "BKN" "Mostly Cloudy"         "OVC" "Overcast" } {
        set cloud_table($cloud_code) $cloud_desc
    }

    switch -exact -- $ct {
        SKC -
        CLR -
        NCD -
        NSC {
            if {![isknown $cloudstype]} {
                set cloudstype SKC
            } else {
                lappend cloudstype SKC
            }
            set cloudstr $cloud_table($ct)
        }
        FEW -
        SCT -
        BKN -
        OVC {
            if {![isknown $cloudstype]} {
                set cloudstype $ct
            } else {
                lappend cloudstype $ct
            }
            set cloudstr $cloud_table($ct)
        }
    }
    if {$ch != "" } {
        set ch [scan $ch "%d"]
        if {![isknown $cloudsheight]} {
            set cloudsheight [expr {round($ch * 30.48)}]
        } else {
            lappend cloudsheight [expr {round($ch * 30.48)}]
        }
    }
    switch -exact -- $cbtcu {
        CB {
            set cumulonimbus 1
        }
        TCU {
            set toweringcumulus 1
        }
        default {
        }
    }
}

proc parse_weather { int vic desc wea weathernm weathercodenm} {

    upvar 1 $weathernm weather
    upvar 1 $weathercodenm icon

    set wc $icon

    foreach {condition_code condition_desc} { \
        ""   ""        "-"  "Light"        "+"  "Heavy"         "VC" "Nearby" \
        \
        "MI" "Shallow" "BC" "Patches"      "BL" "Blowing"       "TS" "Thunderstorms" \
        "PR" "Partial" "DR" "Low Drifting" "SH" "Showers"       "FZ" "Freezing" \
        \
        "RA" "Rain"    "SN" "Snow"         "IC" "Ice Crystals"  "GR" "Hail" \
        "DZ" "Drizzle" "SG" "Snow Grains"  "PL" "Ice Pellets"   "GS" "Small Hail" \
        "UP" "Unknown Precipitation" \
        \
        "BR" "Mist"    "FG" "Fog"          "FU" "Smoke"         "VA" "Volcanic Ash" \
        "SA" "Sand"    "HZ" "Haze"         "PY" "Spray"         "DU" "Widespread Dust" \
        \
        "SQ" "Squall"  "DS" "Duststorm"    "FC" "Funnel Cloud" \
        "SS" "Sandstorm"                   "PO" "Dust/Sand Whirls"} {
            set condition_table($condition_code) $condition_desc
    }

# debug "Weather: $int, $desc, $wea, $vic, $wc" red

    if {[string length $int] != 0 } {
        set wl $condition_table($int)
    }
    if {[string length $desc] != 0 } {
        append wl " " $condition_table($desc)
    }
    if {[string length $wea] != 0 } {
        append wl " " $condition_table($wea)
    }
    if {[string length $vic] != 0 } {
        append wl " " $condition_table($vic)
    }
    if {![isknown $weather]} {
        set weather $wl
    } else {
        set weather [format "%s, %s" $weather $wl]
    }

    if {[string match "*TS*" $desc] || [string match "*TS*" $wea]} {
        if {[string match "*VC*" $vic]} {
            set wc "hi_tsra"
        } else {
            set wc "tsra"
        }
    } elseif {[string match "*DZ*" $wea]} {
        if {[string match "*FZ*" $desc]} {
            set wc "fzrara"
        } else {
            set wc "ra1"
        }
   } elseif {[string match "*SH*" $wea]} {
        if {[string match "*VC*" $vic]} {
            set wc "hi_shwrs"
        } else {
            set wc "shra"
        }
    } elseif {[string match "*RA*" $wea]} {
        if {[string match "*IC*" $desc] || [string match "*PL*" $desc]} {
            set wc "raip"
        } elseif {[string match "*SN*" $wea]} {
            if {[string match "*FZ*" $desc]} {
                set wc "mix"
            } else {
                set wc "rasn"
            }
        } elseif {[string match "*FZ*" $desc]} {
            set wc "fzra"
        } elseif {[string match "*SH*" $desc]} {
            if {[string match "*VC*" $vic]} {
                set wc "hi_shwrs"
            } else {
                set wc "shra"
            }
        } elseif {[string match "*-*" $int]} {
            set wc "ra1"
        } else {
            set wc "ra"
        }
    } elseif {[string match "*SQ*" $wea]} {
        set wc "shra"
    } elseif {[string match "*FC*" $wea]} {
        set wc "nsvrtsra"
    } elseif {[string match "*SN*" $wea]} {
        if {[string match "*+*" $int]} {
            set wc "blizzard"
        } else {
            set wc "sn"
        }
    } elseif {[string match "*SG*" $wea]} {
            set wc "sn"
    } elseif {[string match "*IP*" $wea] || [string match "*IC*" $wea] || \
              [string match "*GR*" $wea] || [string match "*GS*" $wea] || \
              [string match "*PL*" $wea]} {
        set wc "ip"
    } elseif {![string match "*ra*" $wc] && ![string match "*mix*" $wc] && \
              ![string match "*sh*" $wc] && ![string match "*ip*" $wc] && \
              ![string match "*sn*" $wc] && ![string match "*blizz*" $wc]} {
        if {[string match "*FG*" $wea]} {
            set wc "fg"
        } elseif {[string match "*HZ*" $wea] || [string match "*BR*" $wea]} {
            set wc "mist"
        } elseif {[string match "*FU*" $wea] || [string match "*VA*" $wea]} {
            set wc "smoke"
        } elseif {[string match "*SA*" $wea] || [string match "*DS*" $wea] || \
                  [string match "*SS*" $wea] || [string match "*PO*" $wea] || \
                  [string match "*DU*" $wea]} {
            set wc "dust"
        }
    } else {
        if {![isknown $wc] } {
                set wc "na"
        }
    }
    set icon $wc$::Iconext
#    debug "parse_weather: $weather, icon: $icon" red
}

proc parse_international_visibility { m visibilitynm } {

    upvar 1 $visibilitynm visibility
    set visibility [scan $m "%d"]
}

proc parse_american_visibility { v1 v2 prevf visibilitynm } {
    upvar 1 $visibilitynm visibility
    if { ([string length $v2] == 0) || ($v2 eq "0")} {
        set v2 1
    }
    append v2 ".0"
    if {![string is integer -strict $prevf]} {
        set prevf 0
    }
    set visibility [expr {$prevf + $v1/$v2}]
}

#! Parsing procedure for METAR current weather
proc parseMETARnwscur { metarl mi_abbrev } {
    global Wx Config StationNames Cvar

    debug "parseMETARnwscur" blue

    initwxdata $metarl $mi_abbrev

    set prevf ""
    set mi_abbrev_found 0

    foreach f $metarl {
#       debug "token: >>$f<<"
        if {$mi_abbrev eq $f} {
            set mi_abbrev_found 1
            if {[info exists StationNames($mi_abbrev)]} {
                set loc [format "%s" $StationNames($mi_abbrev)]
                if {[info exists StationNames($mi_abbrev,state)]} {
                    set loc [format "%s, %s" $loc $StationNames($mi_abbrev,state)]
                }
            } else {
                set loc $mi_abbrev
            }
            set Wx(Location) $loc
            continue
        }
        if { !$mi_abbrev_found && [regexp {([0-9]{4})/([0-9]{2})/([0-9]{2})} $f m y m d]} {
            set Wx(year)   [scan $y "%d"]
            set Wx(month)  [scan $m "%d"]
            set Wx(day)    [scan $d "%d"]
        } elseif { !$mi_abbrev_found && [regexp {([0-9]{2}):([0-9]{2})} $f ma h m]} {
            set Wx(hour)   [scan $h "%d"]
            set Wx(minute) [scan $m "%d"]
        } elseif { !$mi_abbrev_found } {
            continue
        } elseif {[string match "RMK*" $f] || [string match "TEMP*" $f] || \
                   [string match "NOSIG*" $f] || [string match "BECMG*" $f]} {
            break
        } elseif {[regexp {([0-9][0-9])([0-9][0-9])([0-9][0-9])Z} $f ma d h m]} {
            # Date/time field
            set Wx(day)    [scan $d "%d"]
            set Wx(hour)   [scan $h "%d"]
            set Wx(minute) [scan $m "%d"]

        } elseif {$f eq "COR"} {
            set Wx(corrected) 1
        } elseif {$f eq "AUT"} {
            set Wx(corrected) 0
        } elseif {[string match {R[0-9][0-9][LCR]*} $f]} {
            # Runway visibility still to be added
        } elseif {[regexp {([0-9/]{3}|VRB)([0-9/]{2,3})(G[0-9]{2,3})?(KT|KMH|MPS)} $f m wd ws wg wu]} {
            # Wind field
            parse_wind $f $wd $ws $wg $wu "" Wx
        } elseif {[regexp {([0-9]{3})V([0-9]{3})} $f m wvf wvt]} {
            # Wind variability
            parse_wind_variability $wvf Wx(windvarfrom) Wx(windvarfromstr) $wvt Wx(windvarto) Wx(windvartostr)
        } elseif {[regexp {^(M?[0-9][0-9])/+(M?[0-9/][0-9/])?$} $f m temp dewp]} {
            # Temperature field
            parse_temperature $temp Wx(TempC)
            parse_temperature $dewp Wx(DewpointC)

        } elseif {[regexp {(A|Q)([0-9]{4})} $f m pu pv]} {
            # Altimeter settings field
            switch -exact -- $pu {
                "A" {
                    set Wx(PressureIn) \
                    [scan [string range $pv 0 1] "%d"].[string range $pv 2 3]
                }
                "Q" {
                    set Wx(PressureMb) [scan $pv "%d"]
                }
            }
        } elseif {[regexp {(SKC|FEW|SCT|BKN|OVC|CLR|NSC|NCD)([0-9]{3})?(CB|TCU)?} $f m ct ch cbtcu]} {
            # Clouds field
            parse_clouds $ct Wx(cloudstype) $ch Wx(cloudsheight) $cbtcu Wx(toweringcumulus) Wx(cumulonimbus) Wx(cloudstr)

        } elseif {$f eq "CAVOK"} {
            set Wx(cloudstype) "SKC"
            set Wx(cloudsheight) "CAVOK"
            set Wx(cumulonimbus) 0
            set Wx(toweringcumulus) 0
            set Wx(cloudstr) "Clear skies"
            set Wx(WeatherIcon) "skc$::Iconext"
            set Wx(VisibilityKm) 10000
            set Wx(VisibilityMi) 10

        } elseif {[regexp {([\+\-]?)(VC)?(MI|BC|PR|TS|BL|SH|DR|FZ)?(DZ|RA|SH|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|SS|DS|FC|\+FC|TS)} $f m int vic desc wea]} {
            # Weather field
#          debug "Wx: $f >$int< >$vic< >$desc< >$wea< "
            if {[string equal -length 2 $f "RE"]} {
                # special case of RExxxx, until sure of meaning of this.
                continue;
            }
            parse_weather $int $vic $desc $wea Wx(Weather) Wx(WeatherIcon)
            while { 1 } {
                set f [string range $f [string length $m] end]
                if {![regexp {([\+\-]?)(VC)?(MI|BC|PR|TS|BL|SH|DR|FZ)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|PO|SQ|SS|DS|FC|\+FC|TS)} $f m int vic desc wea]} {
                    break
                }
                if {[string equal -length 2 $f "RE"]} {
                    # special case of RExxxx, until sure of meaning of this.
                    continue;
                }
                parse_weather $int $vic $desc $wea Wx(Weather)  Wx(WeatherIcon)
            }

        } elseif {[regexp {^([0-9]{4})([NS]?[EW]?)$} $f m d]} {
            # International visibility field
            parse_international_visibility $m Wx(VisibilityKm)

        } elseif {[regexp {^([0-9]{1,2})/?([0-9]{0,2})(SM|KM)$} $f m v1 v2 u]} {
            # American visibility field
            set vis 0
            parse_american_visibility $v1 $v2 $prevf vis
            switch -exact -- $u {
                "SM" {
                    set Wx(VisibilityMi) $vis
                }
                "KM" {
                    set Wx(VisibilityKm) [format "%.0f" [expr {$vis * 1000}]]
                }
            }
        }
        # Visibility directions still to be added
        set prevf $f
    }

    set tm [get_time  Wx]
    set ot [clock format $tm \
        -format "Last Updated on [timedatefmt]"]
    set Wx(ObservationTime) $ot
    set otrfc [clock format $tm \
        -format "%a, %e %b %Y %T %z"]
    set Wx(ObservationTimerfc822) $otrfc
    set Wx(year) [clock format $tm -format %Y]
    set Wx(month) [clock format $tm -format %m]
    set Wx(day) [clock format $tm -format %d]
    set Wx(hour) [clock format $tm -format %H]
    set Wx(minute) [clock format $tm -format %M]
    set Wx(time-zone) [clock format $tm -format %z]
    debug "$ot"

    wxpostprocess
    downloadicon "" $Wx(IconBase)$Wx(WeatherIcon)

    debug [clock format [clock seconds] \
        -format "Fetched [timedatefmt]"]
    set Wx(FetchTime) [clock format [clock seconds] \
        -format "[timedatefmt]"]
    set Wx(FetchStatus) "Succeeded"

    debug "Weather for $mi_abbrev:"
    varset Wx Wxcfg
    foreach v [lsort -dictionary [array names Cvar]] {
        sethvwxvars $v $Wx($Cvar($v))
    }

    wxweb
    wxmqtt
    wxspeech
}

proc get_time { arnm } {
    upvar 1 $arnm Wx

    return [clock scan \
           [format "%d:%d;%d/%d/%d" \
            $Wx(hour) $Wx(minute) $Wx(day) $Wx(month) $Wx(year) ] \
           -format "%k:%M;%e/%N/%Y" -timezone :UTC ]
}

#! Fake enough of the log package to satisfy the ftp package
namespace eval log {
    proc log {level text} {
        debug [format {%-9s %s} $level $text]
    }
}
package provide log 1.0

package require ftp

#!**************
#
# Portions of the following source were obtained from:
#
# http://wiki.tcl.tk/19635
#
# tclmetar 0.1 by: Jos Decoster http://jos.decoster.googlepages.com/
#
namespace eval ::tclmetar {
    variable ftpsock
}

proc ::tclmetar::ftpopen { ftpserver ftpuser ftppassword ftpdir ftpmode } {
    variable ftpsock

    set ftpsock [ftp::Open $ftpserver $ftpuser $ftppassword -mode $ftpmode]
    ftp::Cd $ftpsock $ftpdir
}

proc ::tclmetar::ftpget { mfile } {
    variable ftpsock

    set mdata ""
    set rt [ftp::Get $ftpsock $mfile -variable mdata]
    if {[string length $rt] && $rt } {
        set mdata [string map {\n " " \r " " \t " "} [string trim $mdata]]
        return [eval list [split $mdata]]
    } else {
        return -code error "Could not download file '$mfile'"
    }
}

proc ::tclmetar::ftpclose { } {
    variable ftpsock

    ftp::Close $ftpsock
}

proc get_metar_data { mi_abbrev } {
    global Config

    set ftpserver $Config(FTPServer)
    set ftpdir $Config(FTPDir)
    set ftpmode $Config(FTPMode)
    set ftpuser anonymous
    set ftppassword anonymous

    set tVerbose $::ftp::VERBOSE
    set ::ftp::VERBOSE 1
    tclmetar::ftpopen $ftpserver $ftpuser $ftppassword $ftpdir $ftpmode
    set rt [catch {tclmetar::ftpget $mi_abbrev.TXT} mi_data]
    tclmetar::ftpclose
    set ::ftp::VERBOSE $tVerbose
    debug "RT1: $rt"
    if { $rt } {
        return -code error $mi_data
    }

    if {[catch {parseMETARnwscur $mi_data $mi_abbrev} rl]} {
        wxfail Parse METAR $rl $data
    }
    return $rl
}

# End tclmetar
#****************

#! Procedure to get weather data
#  WeatherSetVar ?0|1 ?wx|fc|wxfc|fcwx??
#    Default: 0 wxfc (fetch both current and forecast in background)
hvPublic WeatherSetVar
proc WeatherSetVar {args} {
    global Config LinkA WxAfter getMode

    if {$Config(ReadEnable) == 0} {return}
    lassign $args now mode
    if {$now eq "" || $now == 0} {
        set now 0
    } else {
        set now 1
    }
    if {$mode eq ""} {
        set mode "wxfc"
    }
    set getMode $mode
    set w [string match {*wx*} $mode]
    set f [string match {*fc*} $mode]
    # set up time for next call
    if {$now == 0} {
        after cancel $WxAfter
        if {$Config(ReadTime) > 0} {
            set WxAfter [after [expr {$Config(ReadTime) * 60000}] [list WeatherSetVar 0 $mode]]
        }
    }
    set cmd ""
    if {$Config(DataSource) eq "Web"} {
        if {$Config(WeatherType) eq "X" && $w} {
            if {[catch {downloadhttp nwscur $LinkA(nwscur) $now} wl]} {
                wxfail "Fetch" NWSCUR $wl
            }
        } elseif {$Config(WeatherType) eq "W" && $w} {
            validatewb
            if {[catch {downloadhttp wbcur $LinkA(wbcur) $now} wl]} {
                wxfail "Fetch" WBCUR $wl
            }
        } elseif {$Config(WeatherType) eq "M" && $w} {
        debug "link:$LinkA(nwscur)" red
            regexp -nocase {https*://.+/([[:alnum:]]+)\.xml} $LinkA(nwscur) --> stationid
            if {[catch {get_metar_data $stationid} wl]} {
                wxfail "Fetch" METARCUR $wl
            }
        }
        if {$Config(ForecastEnable) eq "X" && $f} {
            if {[catch {downloadhttp nwsfc [format $LinkA(nwsfc) [clock format [clock scan now] -format "%Y-%m-%d"]] $now} wl]} {
                wxfail "Fetch" NWSFC $wl
            }
        } elseif {($Config(ForecastEnable) eq "W" && $f) && \
                (!($Config(WeatherType)    eq "W" && $w) || \
                 (($Config(WeatherType)    eq "W" && $w) && \
                  $Config(LocSelection) == 0))} {
            validatewb
            debug "Separate OW Fetch" red
            if {[catch {downloadhttp wbfc $LinkA(wbfc) $now} wl]} {
                wxfail "Fetch" WBFC $wl
            }
        }
    } else {
        if {$Config(WeatherType) ne "N" && $w} {fileCBall cur $Config(FileSource)}
        if {$Config(ForecastEnable) ne "N" && $f} {fileCBall fc $Config(FileSourceFc)}
    }
    return
}

#! Set weather parameters
#  WeatherSet ?current | forecast | both? \
#      Station ?stationID ?stationname?? | ZipCode ?code? | \
#      LatLong ?lat long | lat,long? | HVLatLong | \
#      None | NWS | METAR | OpenWeather | \
#      Go
#   "WeatherSet current Station" is the same as WeatherSetStation

hvPublic WeatherSet
proc WeatherSet {type args} {
    global tmpConfig Config StationNames
    set wx {forecast current}
    set type [string tolower $type]
    if {$type eq "both"} {
        set args [lassign $args type]
    } elseif {$type in $wx} {
        set wx $type
        set args [lassign $args type]
    }
    lassign $args a b
    debug "WeatherSet: $wx,$type,$args,$a,$b" red

    switch -nocase $type {
        Station {
            if {[regexp {[a-zA-Z0-9]{4,5}} $a]} {
                set a [string toupper $a]
                if {$b eq ""} {
                    if {![info exists StationNames($a)]} {
                        set b $a
                    } else {
                        set b $StationNames($a)
                    }
                }
                if {"forecast" in $wx} {
                    set tmpConfig(StationIDFc) $a
                    set tmpConfig(StationNameCurrent) "$b"
                    set Config(StationIDFc) $a
                    set Config(StationNameCurrent) "$b"
                    set Config(SearchTypeFc) "S"
                    set tmpConfig(SearchTypeFc) "S"
                }
                if {"current" in $wx} {
                    set tmpConfig(StationID) $a
                    set tmpConfig(StationNameCurrent) "$b"
                    set Config(StationID) $a
                    set Config(StationNameCurrent) "$b"
                    set Config(SearchType) "S"
                    set tmpConfig(SearchType) "S"
                }
            } elseif {$a eq "" && $b eq ""} {
                if {"forecast" in $wx} {
                    set Config(SearchTypeFc) "S"
                    set tmpConfig(SearchTypeFc) "S"
                }
                if {"current" in $wx} {
                    set Config(SearchType) "S"
                    set tmpConfig(SearchType) "S"
                }
            }
        }
        ZipCode {
            if {[string match {[0-9]*} $a] && \
                        [string length $a] == 5}  {
                if {"forecast" in $wx} {
                    set Config(ZipCodeFc) $a
                    set tmpConfig(ZipCodeFc) $a
                    set Config(SearchTypeFc) "Z"
                    set tmpConfig(SearchTypeFc) "Z"
                }
                if {"current" in $wx} {
                    set Config(ZipCode) $a
                    set tmpConfig(ZipCode) $a
                    set Config(SearchType) "Z"
                    set tmpConfig(SearchType) "Z"
                }
            } elseif {$a eq "" && $b eq ""} {
                if {"forecast" in $wx} {
                    set Config(SearchTypeFc) "Z"
                    set tmpConfig(SearchTypeFc) "Z"
                }
                if {"current" in $wx} {
                    set Config(SearchType) "Z"
                    set tmpConfig(SearchType) "Z"
                }
            }
        }
        LatLong {
            if {[llength $args] == 1} {
                regexp {([0-9+-.]+),([0-9+-.]+)} $a --> a b
            }
            if {$a >= -90 && $a <= 90 && $b >= -180 && $b <= 180} {
                if {"forecast" in $wx} {
                    set Config(LatitudeFc) $a
                    set tmpConfig(LatitudeFc) $a
                    set Config(LongitudeFc) $b
                    set tmpConfig(LongitudeFc) $b
                    set Config(SearchTypeFc) "L"
                    set tmpConfig(SearchTypeFc) "L"
                }
                if {"current" in $wx} {
                    set Config(Latitude) $a
                    set tmpConfig(Latitude) $a
                    set Config(Longitude) $b
                    set tmpConfig(Longitude) $b
                    set Config(SearchType) "L"
                    set tmpConfig(SearchType) "L"
                }
            } elseif {$a eq "" && $b eq ""} {
                if {"forecast" in $wx} {
                    set Config(SearchTypeFc) "L"
                    set tmpConfig(SearchTypeFc) "L"
                }
                if {"current" in $wx} {
                    set Config(SearchType) "L"
                    set tmpConfig(SearchType) "L"
                }
            }
        }
        HVLatLong {
            if {"forecast" in $wx} {
                set Config(SearchTypeFc) "H"
                set tmpConfig(SearchTypeFc) "H"
            }
            if {"current" in $wx} {
                set Config(SearchType) "H"
                set tmpConfig(SearchType) "H"
            }
        }
        None {
            if {"forecast" in $wx} {
                set Config(ForecastEnable) "N"
                set tmpConfig(ForecastEnable) "N"
            }
            if {"current" in $wx} {
                set Config(WeatherType) "N"
                set tmpConfig(WeatherType) "N"
            }
        }
        NWS {
            if {"forecast" in $wx} {
                set Config(ForecastEnable) "X"
                set tmpConfig(ForecastEnable) "X"
            }
            if {"current" in $wx} {
                set Config(WeatherType) "X"
                set tmpConfig(WeatherType) "X"
            }
        }
        METAR {
            if {"current" eq $wx} {
                set Config(WeatherType) "M"
                set tmpConfig(WeatherType) "M"
            }
        }
        OpenWeather {
            if {"forecast" in $wx} {
                set Config(ForecastEnable) "W"
                set tmpConfig(ForecastEnable) "W"
            }
            if {"current" in $wx} {
                set Config(WeatherType) "W"
                set tmpConfig(WeatherType) "W"
            }
        }
        Go {
            WeatherSetVar 1
        }
    }
    if {[winfo exists .cfg]} {
        enabledatasource .cfg.n
    }
    init
    return ""
}

#! External interface for other plug-ins to set station ID and name
#  Retained for backward compatibility.
#  WeatherSetStation stationID ? stationname?
hvPublic WeatherSetStation
proc WeatherSetStation {a {b ""}} {
    global tmpConfig Config StationNames LinkA
    WeatherSet current station $a $b
    return ""
}

#! Get weather info for html page
#  WeatherGet {?table?  weather_item ?weather_item?} | {ftable ?num?}
#  table: "ftable" - display forecast table for Num days
#         "table"  - display current weather table with weather_items
hvPublic WeatherGet
proc WeatherGet {args} {
#   debug "WeatherGet: $args" red
    global Wx Fx dir

    set vars {}
    set wlist [array names Wx]
    set flist [array names Fx]
    foreach a $args {
        set found 0
        foreach l $wlist {
            if {[string tolower $a] eq [string tolower $l]} {
                lappend vars $l $Wx($l)
                incr found
                break
            }
        }
        if {$found > 0} continue
        foreach l $flist {
            if {[string tolower $a] eq [string tolower $l]} {
                lappend vars $l $Fx($l)
                break
            }
        }
    }

    set option [string tolower [lindex $args 0]]
    if {$option eq "ftable"} {
        set max [lindex $args 1]
        if {[string is integer -strict $max]} {
            if {$max >= 1 && $max <= 7} {
            } else {
                set max 7
            }
        } else {
            set max 7
        }
        lappend ret {<table>}
        lappend ret {<tr class="head">}
        lappend ret [format {<th colspan="4">Forecast for %s</th>}  $Fx(FcLoc)]
        lappend ret {</tr>}

        for {set i 1; set n ""} {$i <= $max} {incr i; set n ""} {
            if {$Fx(FcImg$i) eq ""} {
                if {$i == 1 && $Fx(FcImgn$i) ne ""} {
                    set n "n"
                    set icon $Fx(FcImgn$i)
                } else {
                    if {[string match "*openweather*" $Fx(FcIconBase)]} {
                        set icon 01d.png
                    } else {
                        set icon na$::Iconext
                    }
                    downloadicon fc $Fx(FcIconBase)$icon
                }
            } else {
                set icon $Fx(FcImg$i)
            }
            set ext [string trim [file extension $icon] "."]
            lappend ret [format {<tr class="%s"><td>%s</td><td>%s/%s</td><td><HV:Image %s WeatherGetIcon %s></td><td>%s</td></tr>} \
                [expr {($i % 2) ? {even} : {odd}}] $Fx(FcDay$n$i) $Fx(FcHi$i) $Fx(FcLo$i) $ext $icon $Fx(FcLc$n$i)]
        }
        lappend ret {</table>}

    } elseif {$option eq "table"} {
        if {[llength $vars] == 0} return
        lappend ret {<table>}
        lappend ret {<tr class="head">}
        lappend ret {<th colspan="2">Current Weather</th>}
        lappend ret {</tr>}
        set i 0
        foreach {a v} $vars {
            if {$a eq "WeatherIcon" || [string equal -length 5 $a "FcImg"]} {
                if {$v eq "" && [string equal -length 5 $a "FcImg"]} {
                    if {[string match "*openweather*" $Fx(FcIconBase)]} {
                        set icon 01d.png
                    } else {
                        set icon na$::Iconext
                    }
                    downloadicon fc $Fx(FcIconBase)$icon
                } else {
                    set icon $v
                }
                set ext [string trim [file extension $icon] "."]
                lappend ret [format {<tr class="%s"><td>%s</td><td><HV:Image %s WeatherGetIcon %s></td></tr>} \
                    [expr {($i % 2) ? {even} : {odd}}] $a $ext $icon]
            } else {
                lappend ret [format {<tr class="%s"><td>%s</td><td>%s</td></tr>} \
                    [expr {($i % 2) ? {even} : {odd}}] $a $v]
            }
            incr i
        }
        lappend ret {</table>}

    } else {
        if {[llength $vars] == 0} return
        foreach {a v} $vars {
            if {$a eq "WeatherIcon" || [string equal -length 5 $a "FcImg"]} {
                if {$v eq "" && [string equal -length 5 $a "FcImg"]} {
                    if {[string match "*openweather*" $Fx(FcIconBase)]} {
                        set icon 01d.png
                    } else {
                        set icon na$::Iconext
                    }
                    downloadicon fc $Fx(FcIconBase)$icon
                } else {
                    set icon $v
                }
                set ext [string trim [file extension $icon] "."]
                lappend ret [format {<HV:Image %s WeatherGetIcon %s>} $ext $icon]

            } else {
                lappend ret "$v"
            }
        }
    }
    return  [join $ret "\n"]
}

#! Return icon data for specified icon
hvPublic WeatherGetIcon
proc WeatherGetIcon {args} {
    global dir Wx Fx

    if {[llength $args] > 0} {
        if {[lindex $args 0] eq "WeatherIcon" } {
            set img $Wx(WeatherIcon)
        } elseif {[string equal -length 5 [lindex $args 0] "FcImg"]} {
            set img $Fx([lindex $args 0])
        } else {
            set img [lindex $args 0]
        }
    } else {
            set img $Wx(WeatherIcon)
    }
#    debug "WeatherGetIcon:$img" red
    if {[file extension $img] eq ""} {set img $img$::Iconext}
    set file [file join $dir weather images $img]
#    debug "WeatherGetIcon: file:$img;$file;" darkred
    if {[catch {open $file} f]} {
        debug "WeatherGetIcon: File open failed: $file, $f" red
        return
    }
    fconfigure $f -translation binary
    set ret [read $f]
    catch {close $f}
    return $ret
}

#! Send wx current info to json weather plug-in to send over websockets
hvImport html_Image
hvImport wsupdate
proc wxweb {} {
    global Wx Config Wxcfg

    set empty 1
    foreach name [dict keys $Wxcfg] {
#   debug "$name: [dict get $Wxcfg $name web_enable]" red
        if {[dict get $Wxcfg $name web_enable]} {
            set empty 0
            if {$name eq "WeatherIcon"} {
                set icon ""
                if {[isknown $Wx(WeatherIcon)]} {
                    set fn [file rootname $Wx(WeatherIcon)]
                    set ext [string trim [file extension $Wx(WeatherIcon)] "."]
                    set link [html_Image "$ext WeatherGetIcon $fn.$ext"]
                    if {$link != ""} {
                        regexp {<img src="(.+)" alt=} $link --> icon
                    }
                }
                lappend tfmt [formatwx "img" $icon]
            } else {
                lappend tfmt [formatwx $name $Wx($name)]
            }
        }
    }
    if {!$empty} {wsupdate wx [format {{{%s}}} [join $tfmt ", "]]}
}

#! Send wx forecast info to json weather plug-in to send over websockets
proc fcweb {} {
    global Fx Fxcfg

    set tfmt {}
    set empty 1
    foreach name {Loc City State Zip Country Ccode Lat Long \
                  Time Fetch FetchStatus IconBase SearchType} {
        if {[dict get $Fxcfg Fc$name web_enable]} {
            set empty 0
            lappend tfmt [formatwx $name $Fx(Fc$name)]
        }
    }
    if {[llength $tfmt]} {
        lappend fmt "{{[join $tfmt ", "]}}"
    } else {
        lappend fmt "{}"
    }

    # get the daily items list
    set items ""
    foreach j [dict keys $Fxcfg] {
        regexp  {^Fc(.+)[1-7]$} $j --> jj
        if {[info exists jj] && $jj ne ""} {
            lappend items $jj
        }
    }
    set items [lsort -unique $items]
#    debug "fcweb:$items" red

    for {set i 1} {$i < 8} {incr i} {
        set tfmt {}
        foreach name $items {
            set longname Fc$name$i
            if {[dict get $Fxcfg $longname web_enable]} {
                set empty 0
                if {[string equal -length 3 $name "Img"]} {
                    set icon ""
                    if {$Fx($longname) ne ""} {
                        set fn [file rootname $Fx($longname)]
                        set ext [string trim [file extension $Fx($longname)] "."]
                        set link [html_Image "$ext WeatherGetIcon $fn.$ext"]
                        if {$link != ""} {
                            regexp {<img src="(.+)" alt=} $link --> icon
                        }
                    }
                    lappend tfmt [formatwx $name $icon]
                } else {
                    lappend tfmt [formatwx $name $Fx($longname)]
                }
            }
        }
        lappend fmt "{{[join $tfmt ", "]}}"
    }
    if {!$empty} {wsupdate fc [format {%s} [join $fmt " "]]}
}

proc formatwx {n v} {
    global Wx
    set val [expr {[isknown $v]?$v:"NA"}]
    set val [string map {\" \\\" \n " "} $val]
    if {![string is double -strict $val]} {
        set val "\"$val\""
    }
    #debug "formatwx: $n;$v;$val" red
    return "\"[string tolower $n]\": $val"
}

#! Send wx current info to MQTT
hvImport mqttComm
proc wxmqtt {} {
    global Wx Config Wxcfg

    set empty 1
    foreach name [dict keys $Wxcfg] {
 #  debug "$name: [dict get $Wxcfg $name mqtt_enable]" red
        if {[dict get $Wxcfg $name mqtt_enable]} {
            set empty 0
                lappend tfmt [formatwx $name $Wx($name)]
            }
        }
    if {!$empty} {
        set json [format {{"wx":{%s}}} [join $tfmt ","]] 
#        debug "json:$json;" red
        if {$Config(StateTopic) ne ""} {
            if {$Config(MqttRetain)} {
                set retain "-retain"
            } else {
                set retain ""
            }
            mqttComm {*}$retain pub $Config(StateTopic) $json 
        }
    }
}

#! Send wx forecast info to MQTT
proc fcmqtt {} {
    global Fx Fxcfg Config

    set tfmt {}
    set empty 1
    foreach name {Loc City State Zip Country Ccode Lat Long \
                  Time Fetch FetchStatus IconBase SearchType} {
        if {[dict get $Fxcfg Fc$name mqtt_enable]} {
            set empty 0
            lappend tfmt [formatwx $name $Fx(Fc$name)]
        }
    }
    if {[llength $tfmt]} {
        lappend fmt "[join $tfmt ","],"
    }
    # get the daily items list
    set items ""
    foreach j [dict keys $Fxcfg] {
        regexp  {^Fc(.+)[1-7]$} $j --> jj
        if {[info exists jj] && $jj ne ""} {
            lappend items $jj
        }
    }
    set items [lsort -unique $items]
#    debug "fcweb:$items" red

    for {set i 1;set first 1} {$i < 8} {incr i} {
        set tfmt {}
        set dayempty 1
        foreach name $items {
            set longname Fc$name$i
            if {[dict get $Fxcfg $longname mqtt_enable]} {
                set empty 0
                set dayempty 0
                    lappend tfmt [formatwx $name $Fx($longname)]
            }
        }
        if {!$dayempty} {
            if {$first == 1} {
                set first 0
                lappend fmt [format {"day%d":} $i]
            } else {
            lappend fmt [format {,"day%d":} $i]
            }
            lappend fmt "{[join $tfmt ","]}"
        }
    }
    if {!$empty} {
        append json "{\"fc\":{" [format {%s} [join $fmt ""]] "}}"
#        debug "json:$json;" red
       
        if {$Config(StateTopic) ne ""} {
            if {$Config(MqttRetain)} {
                set retain "-retain"
            } else {
                set retain ""
            }
            mqttComm {*}$retain pub $Config(StateTopic) $json 
        }
    }
}

hvPublic wxmqttcb
proc wxmqttcb {topic payload {retain 0}} {
    global Config

    set args [lassign $payload command]
    if {$command in {WeatherSetVar WeatherSet}} {
        $command {*}$args
    }
}

proc subscribe {{type sub}} {
    global Config

    debug "${type}scribe" blue

    if {$Config(CmndTopic) ne ""} {
        mqttComm $type $Config(CmndTopic) wxmqttcb
    }
}

#! weather processor for netioaction
# netioaction wx|fc|wxfc|fcwx update
# action wx|fc|wxfc|fcwx update
#    updates wx, fc or both
hvPublic netioaction
proc netioaction {type args} {
    if {$type in "wx fc wxfc fcwx" && [lindex $args 0] eq "update"} {
        WeatherSetVar 1 $type
    }
}

#! weather processor for get_update
# events wx|fc|wxfc|fcwx
#    updates wx, fc or both
hvPublic get_update
proc get_update {{type wxfc} args} {
debug "get_update: $type, $args" red
    if {$type in "wx fc wxfc fcwx"} {
        WeatherSetVar 1 $type
    }
}

#! weather processor for netio get
# get wx item
# get fc item day {best}
# "item" to get. Any case. For forecasts, no "fc" or day number in item name.
# "day" (1-7) to get for forecasts. day 0 gets general info.
# "best" (optional) give either day or night version if requested one is null.
hvPublic netio
proc netio {type args} {
    global Wx Fx

    lassign $args item best
    debug "wx netio called: $type, $item, $best;$args" darkgreen
    switch $type {
        wx -
        fc {
            set l [array names Wx]
            if {[set r [lsearch -inline -nocase -exact $l $item]] eq ""} {
                set l [array names Fx]
                if {[set r [lsearch -inline -nocase -exact $l $item]] eq ""} {
                     return ""
                } else {
                    set rc $Fx($r)
                }
            } else {
                set rc $Wx($r)
            }
            if {$rc != "" || $best ne "best" || [string range $r 0 3] ni {FcDa FcSc FcLc FcPo FcIm}} {
                return $rc
            }
            # if original item is empty, it's one of Day, Sc, Lc, Pop or Img, and "best" is set,
            #  return the opposite day/night version of the item
            if {[string index $r end-1] eq "n"} {
                set it [string replace $r end-1 end-1]
            } else {
                set it [string replace $r end end n[string index $r end]]
            }
            if {[set r [lsearch -inline -nocase -exact $l $it]] eq ""} {
                 return ""
            }
            return $Fx($r)
        }
        default {
            return ""
        }
    }
}

hvPublic getWxControlVars
proc getWxControlVars {type var} {
    global Wx Fx
debug "getcv: $type, $var" blue
    switch $type {
        wx {
            set l [array names Wx]
            if {[set r [lsearch -inline -nocase -exact $l $var]] eq ""} {
                return ""
            }
            return $Wx($r)
        }
        fc {
            set l [array names Fx]
            if {[set r [lsearch -inline -nocase -exact $l $var]] eq ""} {
                 return ""
            }
            return $Fx($r)
        }
        default {
            return ""
        }
    }

}

#! Run weather fetch automatically at Control plug-in initialization
#  to make sure Control screen variables are updated quickly
hvPublic ControlInit
proc ControlInit {} {
    WeatherSetVar
}

# Allow triggering of weather from HV
hvTrigger "weather: fetch now"  [list wxserial fetch_now]
hvTrigger "weather: fetch bkgnd"  [list wxserial fetch_bkgnd]
hvTrigger "weather: fetch enable"  [list wxserial fetch_enable]
hvTrigger "weather: fetch disable"  [list wxserial fetch_disable]
hvTrigger "weather: speak now" [list wxserial speak_now]
hvTrigger "weather: speak never" [list wxserial speak_never]
hvTrigger "weather: speak always" [list wxserial speak_always]
hvTrigger "weather: speak serialonly" [list wxserial speak_serialonly]
hvTrigger "weather: hvwxvars enable" [list wxserial hvwxvars_enable]
hvTrigger "weather: hvwxvars disable" [list wxserial hvwxvars_disable]
hvTrigger "weather: station" [list wxserial station_set]
hvTrigger "weather: current" [list wxserial current_set]
hvTrigger "weather: forecast" [list wxserial forecast_set]
hvTrigger "weather: both" [list wxserial both_set]

# redefine debug to allow Sticky bit control
rename debug realdebug
proc debug args {
    global Config

    if {$Config(StickyConfig) == 1} {
        uplevel 1 realdebug $args
    }
}

# Initialize config items
start

# Start fetching
hvEventHook ready [list WeatherSetVar]
hvEventHook exit [list subscribe unsub]
 